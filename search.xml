<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python 统计列表元素出现次数</title>
      <link href="/2018-10-27/Python-%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
      <url>/2018-10-27/Python-%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="利用列表-list-中的-count-来完成统计"><a href="#利用列表-list-中的-count-来完成统计" class="headerlink" title="利用列表 list 中的 count 来完成统计"></a>利用列表 list 中的 count 来完成统计</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_list</span><span class="params">(arr, target)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> arr.count(target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target=2，结果：3</span></span><br></pre></td></tr></table></figure><h3 id="利用字典-dict-来完成统计"><a href="#利用字典-dict-来完成统计" class="headerlink" title="利用字典 dict 来完成统计"></a>利用字典 dict 来完成统计</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">key</span> <span class="keyword">in</span> a:</span><br><span class="line">    dict[<span class="built_in">key</span>] = dict.<span class="built_in">get</span>(<span class="built_in">key</span>, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> dict</span><br></pre></td></tr></table></figure><h3 id="利用-collection-包下-Counter-的类"><a href="#利用-collection-包下-Counter-的类" class="headerlink" title="利用 collection 包下 Counter 的类"></a>利用 collection 包下 Counter 的类</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> collections import Counter</span><br><span class="line"><span class="keyword">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">result</span> = Counter(<span class="keyword">a</span>)</span><br><span class="line">print <span class="built_in">result</span></span><br><span class="line">print dict(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 在字典中根据条件筛选数据</title>
      <link href="/2018-09-22/Python-%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/"/>
      <url>/2018-09-22/Python-%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>首先创建一个字典</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">random</span></span><br><span class="line">import <span class="built_in">time</span></span><br><span class="line"></span><br><span class="line">d = &#123;str(x): <span class="built_in">random</span>.randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'16'</span>: <span class="number">61</span>, <span class="string">'3'</span>: <span class="number">66</span>, <span class="string">'17'</span>: <span class="number">70</span>, <span class="string">'10'</span>: <span class="number">82</span>, <span class="string">'1'</span>: <span class="number">71</span>, <span class="string">'18'</span>: <span class="number">89</span>, <span class="string">'5'</span>: <span class="number">83</span>, <span class="string">'4'</span>: <span class="number">97</span>, <span class="string">'19'</span>: <span class="number">77</span>, <span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'8'</span>: <span class="number">73</span>, <span class="string">'11'</span>: <span class="number">74</span>, <span class="string">'15'</span>: <span class="number">60</span>, <span class="string">'13'</span>: <span class="number">68</span>, <span class="string">'20'</span>: <span class="number">80</span>, <span class="string">'7'</span>: <span class="number">62</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'6'</span>: <span class="number">85</span>, <span class="string">'14'</span>: <span class="number">83</span>, <span class="string">'9'</span>: <span class="number">87</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>现有一个需求, 需要此列表中筛选出值大于 90 的 id(key) 都有哪些 ？</p><p>以下给出四种实现方式</p><h3 id="第一种方法-循环迭代"><a href="#第一种方法-循环迭代" class="headerlink" title="第一种方法: 循环迭代"></a>第一种方法: 循环迭代</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="keyword">if</span> d[k] &gt; <span class="number">90</span>:</span><br><span class="line">        d2[k] = d[k]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(d2)</span></span></span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126503</span></span><br><span class="line"><span class="number">1500951937.126532</span></span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000029</p><p>###第二种方法: filter 函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="name">time</span>.time())</span><br><span class="line">d5 = list(<span class="name">filter</span>(<span class="name">lambda</span> x: d[x] &gt; <span class="number">90</span>, d))</span><br><span class="line">print(<span class="name">time</span>.time())</span><br><span class="line">print(<span class="name">d5</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果为:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126604</span></span><br><span class="line"><span class="number">1500951937.126618</span></span><br><span class="line">[<span class="symbol">'4</span>', <span class="symbol">'12</span>', <span class="symbol">'2</span>']</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000014</p><h3 id="第三种方法-字典解析式"><a href="#第三种方法-字典解析式" class="headerlink" title="第三种方法: 字典解析式"></a>第三种方法: 字典解析式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line">d3 = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">90</span>&#125;</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(d3)</span></span></span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126555</span></span><br><span class="line"><span class="number">1500951937.126564</span></span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000009</p><h3 id="第四种方法-生成器表达式"><a href="#第四种方法-生成器表达式" class="headerlink" title="第四种方法: 生成器表达式"></a>第四种方法: 生成器表达式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line">d4 = (&#123;k: v&#125; <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">90</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> d4:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126576</span></span><br><span class="line"><span class="number">1500951937.126581</span></span><br><span class="line">&#123;<span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>&#125;</span><br><span class="line">&#123;<span class="string">'2'</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000005</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>在字典数据量较小时，依然推荐使用字典解析式去筛选数据，在数据量较大且数据需要一条一条处理时，生成器依然是最佳的选择</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Map 函数处理字典</title>
      <link href="/2018-09-22/Map-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%AD%97%E5%85%B8/"/>
      <url>/2018-09-22/Map-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = dict(<span class="attribute">addr</span>=<span class="string">'china'</span>, <span class="attribute">name</span>=<span class="string">'samy'</span>)</span><br></pre></td></tr></table></figure><p>map 函数上述字典返回的是一个 list，那如何返回字典呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; map(lambda <span class="symbol">x:</span> x.upper(), a.values())</span><br><span class="line">[<span class="string">'CHINA'</span>, <span class="string">'SAMY'</span>]</span><br></pre></td></tr></table></figure><p>返回字典的方法：<br><a id="more"></a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = dict(name=<span class="string">'samy'</span>,addr=<span class="string">'china'</span>)</span><br><span class="line">&gt;&gt;&gt; dict(zip(<span class="selector-tag">a</span>, map(lambda x: x.upper(), <span class="selector-tag">a</span>.values())))</span><br><span class="line">&#123;<span class="string">'addr'</span>: <span class="string">'CHINA'</span>, <span class="string">'name'</span>: <span class="string">'SAMY'</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = dict(name=<span class="string">'samy'</span>,addr=<span class="string">'china'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.keys()</span><br><span class="line">[<span class="string">'addr'</span>, <span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dict(zip(map(lambda x: x.upper(), <span class="selector-tag">a</span>.keys()), map(lambda x: x.upper(), <span class="selector-tag">a</span>.values())))</span><br><span class="line">&#123;<span class="string">'ADDR'</span>: <span class="string">'CHINA'</span>, <span class="string">'NAME'</span>: <span class="string">'SAMY'</span>&#125;</span><br><span class="line"></span><br><span class="line">﻿﻿&gt;&gt;&gt; map(lambda (k,v): (k+<span class="string">"1"</span>,v+<span class="string">"1"</span>),<span class="selector-tag">a</span>.items())</span><br><span class="line">[(<span class="string">'name1'</span>, <span class="string">'samy1'</span>), (<span class="string">'addr1'</span>, <span class="string">'china1'</span>)]</span><br><span class="line">&gt;&gt;&gt; dict(map(lambda (k,v): (k+<span class="string">"1"</span>,v+<span class="string">"1"</span>),<span class="selector-tag">a</span>.items()))</span><br><span class="line">&#123;<span class="string">'addr1'</span>: <span class="string">'china1'</span>, <span class="string">'name1'</span>: <span class="string">'samy1'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python itertools模块中排列组合函数</title>
      <link href="/2018-08-11/Python-itertools%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"/>
      <url>/2018-08-11/Python-itertools%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">字段类型</th><th style="text-align:center">字段含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>product</code></td><td style="text-align:center">笛卡尔积</td><td style="text-align:center">有放回抽样排列</td></tr><tr><td style="text-align:center"><code>permutations</code></td><td style="text-align:center">排列</td><td style="text-align:center">不放回抽样排列</td></tr><tr><td style="text-align:center"><code>combinations</code></td><td style="text-align:center">组合、没有重复</td><td style="text-align:center">不放回抽样组合</td></tr><tr><td style="text-align:center"><code>combinations_with_replacement</code></td><td style="text-align:center">组合、有重复</td><td style="text-align:center">有放回抽样组合</td></tr></tbody></table><p>详细的参见<a href="https://docs.python.org/2/library/itertools.html" target="_blank" rel="noopener">官网</a></p><a id="more"></a><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">import</span> <span class="selector-tag">itertools</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.product</span>(<span class="string">'ABCD'</span>, repeat = <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>) (<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'A'</span>) (<span class="string">'B'</span>, <span class="string">'B'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'A'</span>) (<span class="string">'C'</span>, <span class="string">'B'</span>) (<span class="string">'C'</span>, <span class="string">'C'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>) (<span class="string">'D'</span>, <span class="string">'A'</span>) (<span class="string">'D'</span>, <span class="string">'B'</span>) (<span class="string">'D'</span>, <span class="string">'C'</span>) (<span class="string">'D'</span>, <span class="string">'D'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.permutations</span>(<span class="string">'ABCD'</span>, <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'A'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'A'</span>) (<span class="string">'C'</span>, <span class="string">'B'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>) (<span class="string">'D'</span>, <span class="string">'A'</span>) (<span class="string">'D'</span>, <span class="string">'B'</span>) (<span class="string">'D'</span>, <span class="string">'C'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.combinations</span>(<span class="string">'ABCD'</span>, <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.combinations_with_replacement</span>(<span class="string">'ABCD'</span>, <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>) (<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'B'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'C'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>) (<span class="string">'D'</span>, <span class="string">'D'</span>)</span><br></pre></td></tr></table></figure><p>还有就是， <code>combinations</code> 和 <code>permutations</code> 返回的是对象地址，原因是在 <code>Python3</code> 里面，返回值已经不再是 <code>list</code> ，而是 <code>iterators</code> （迭代器）， 所以想要使用，只用将 <code>iterator</code> 转换成 <code>list</code> 即可， 还有其他一些函数返回的也是一个对象，需要 <code>list</code> 转换，比如 <code>list(map())</code> 等 。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 内置函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4.01 手动遍历迭代器</title>
      <link href="/2018-06-08/4-01-%E6%89%8B%E5%8A%A8%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2018-06-08/4-01-%E6%89%8B%E5%8A%A8%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="第四章：迭代器与生成器"><a href="#第四章：迭代器与生成器" class="headerlink" title="第四章：迭代器与生成器"></a>第四章：迭代器与生成器</h3><p>迭代是 <code>Python</code> 最强大的功能之一。初看起来，你可能会简单的认为迭代只不过是处理序列中元素的一种方法。然而，绝非仅仅就是如此，还有很多你可能不知道的，比如创建你自己的迭代器对象，在 <code>itertools</code> 模块中使用有用的迭代模式，构造生成器函数等等。这一章目的就是向你展示跟迭代有关的各种常见问题。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想遍历一个可迭代对象中的所有元素，但是却不想使用 <code>for</code> 循环。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了手动的遍历可迭代对象，使用 <code>next()</code> 函数并在代码中捕获 <code>StopIteration</code> 异常。 比如，下面的例子手动读取一个文件中的所有行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manual_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                line = next(f)</span><br><span class="line">                print(line, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>通常来讲， <code>StopIteration</code> 用来指示迭代的结尾。然而，如果你手动使用上面演示的 <code>next()</code> 函数的话，你还可以通过返回一个指定值来标记结尾，比如 <code>None</code> 。</p><p>下面是示例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with <span class="keyword">open</span>(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="built_in">line</span> = <span class="keyword">next</span>(<span class="keyword">f</span>, None)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">line</span> <span class="keyword">is</span> None:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span>(<span class="built_in">line</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>大多数情况下，我们会使用 <code>for</code> 循环语句用来遍历一个可迭代对象。但是，偶尔也需要对迭代做更加精确的控制，这时候了解底层迭代机制就显得尤为重要了。</p><p>下面的交互示例向我们演示了迭代期间所发生的基本细节：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Get the iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; it = iter(items) <span class="comment"># Invokes items.__iter__()</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run the iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it) <span class="comment"># Invokes it.__next__()</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>本章接下来几小节会更深入的讲解迭代相关技术，前提是你先要理解基本的迭代协议机制。所以确保你已经把这章的内容牢牢记在心中。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 迭代器与生成器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4.02 代理迭代</title>
      <link href="/2018-06-08/4-02-%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3/"/>
      <url>/2018-06-08/4-02-%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。你想直接在你的这个新容器对象上执行迭代操作。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>实际上你只需要定义一个 <code>__iter__()</code> 方法，将迭代操作代理到容器内部的对象上去。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._value = value</span><br><span class="line">        <span class="keyword">self</span>._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(<span class="keyword">self</span>._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> iter(<span class="keyword">self</span>._children)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = Node(<span class="number">0</span>)</span><br><span class="line">    child1 = Node(<span class="number">1</span>)</span><br><span class="line">    child2 = Node(<span class="number">2</span>)</span><br><span class="line">    root.add_child(child1)</span><br><span class="line">    root.add_child(child2)</span><br><span class="line">    <span class="comment"># Outputs Node(1), Node(2)</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="symbol">root:</span></span><br><span class="line">        print(ch)</span><br></pre></td></tr></table></figure><p>在上面代码中， <code>__iter__()</code> 方法只是简单的将迭代请求传递给内部的 <code>_children</code> 属性。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>Python</code> 的迭代器协议需要 <code>__iter__()</code> 方法返回一个实现了 <code>__next__()</code> 方法的迭代器对象。如果你只是迭代遍历其他容器的内容，你无须担心底层是怎样实现的。你所要做的只是传递迭代请求既可。</p><p>这里的 <code>iter()</code> 函数的使用简化了代码，<code>iter(s)</code> 只是简单的通过调用 <code>s.__iter__()</code> 方法来返回对应的迭代器对象，就跟 <code>len(s)</code> 会调用 <code>s.__len__()</code> 原理是一样的。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 迭代器与生成器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4.03 使用生成器创建新的迭代模式</title>
      <link href="/2018-06-08/4-03-%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018-06-08/4-03-%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想实现一个自定义迭代模式，跟普通的内置函数比如 <code>range()</code> 、 <code>reversed()</code>不一样。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果你想实现一种新的迭代模式，使用一个生成器函数来定义它。下面是一个生产某个范围内浮点数的生成器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def frange(<span class="keyword">start</span>, <span class="keyword">stop</span>, <span class="keyword">increment</span>):</span><br><span class="line">    x = <span class="keyword">start</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; <span class="keyword">stop</span>:</span><br><span class="line">        yield x</span><br><span class="line">        x += <span class="keyword">increment</span></span><br></pre></td></tr></table></figure><p>为了使用这个函数，你可以用 <code>for</code> 循环迭代它或者使用其他接受一个可迭代对象的函数(比如 <code>sum()</code> 、 <code>list()</code> 等)。示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">n</span> <span class="selector-tag">in</span> <span class="selector-tag">frange</span>(0, 4, 0<span class="selector-class">.5</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(<span class="selector-tag">n</span>)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">0<span class="selector-class">.5</span></span><br><span class="line">1<span class="selector-class">.0</span></span><br><span class="line">1<span class="selector-class">.5</span></span><br><span class="line">2<span class="selector-class">.0</span></span><br><span class="line">2<span class="selector-class">.5</span></span><br><span class="line">3<span class="selector-class">.0</span></span><br><span class="line">3<span class="selector-class">.5</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">list</span>(<span class="selector-tag">frange</span>(0, 1, 0<span class="selector-class">.125</span>))</span><br><span class="line"><span class="selector-attr">[0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>一个函数中需要有一个 <code>yield</code> 语句即可将其转换为一个生成器。跟普通函数不同的是，生成器只能用于迭代操作。下面是一个实验，向你展示这样的函数底层工作机制：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span></span><span class="symbol">:</span></span><br><span class="line">...     print(<span class="string">'Starting to count from'</span>, n)</span><br><span class="line">...     <span class="keyword">while</span> n &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">yield</span> n</span><br><span class="line">...         n -= <span class="number">1</span></span><br><span class="line">...     print(<span class="string">'Done!'</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Create the generator, notice no output appears</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = countdown(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c</span><br><span class="line">&lt;generator object countdown at <span class="number">0x1006a0af0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to first yield and emit a value</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line">Starting to count from <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to the next yield</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to next yield</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to next yield (iteration stops)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line">Done!</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>一个生成器函数主要特征是它只会回应在迭代中使用到的 <code>next</code> 操作。一旦生成器函数返回退出，迭代终止。我们在迭代中通常使用的 <code>for</code> 语句会自动处理这些细节，所以你无需担心。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 迭代器与生成器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4.04 实现迭代器协议</title>
      <link href="/2018-06-08/4-04-%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018-06-08/4-04-%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想构建一个能支持迭代操作的自定义对象，并希望找到一个能实现迭代协议的简单方法。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>目前为止，在一个对象上实现迭代最简单的方式是使用一个生成器函数。 在<code>4.2 小节</code>中，使用 Node 类来表示树形数据结构。你可能想实现一个以深度优先方式遍历树形节点的生成器。 下面是代码示例：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">:</span></span><br><span class="line"><span class="title">    def</span> __init__(self, value):</span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return '<span class="keyword">Node</span><span class="title">(&#123;!r</span>&#125;)'.format(self._value)</span><br><span class="line"></span><br><span class="line">    def add_child(self, <span class="keyword">node</span><span class="title">):</span></span><br><span class="line"><span class="title">        self</span>._children.append(<span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    def</span> __iter__(self):</span><br><span class="line">        return iter(self._children)</span><br><span class="line"></span><br><span class="line">    def depth_first(self):</span><br><span class="line">        yield self</span><br><span class="line">        for c <span class="keyword">in</span> self:</span><br><span class="line">            yield from c.depth_first()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    root = <span class="keyword">Node</span><span class="title">(0</span>)</span><br><span class="line">    child1 = <span class="keyword">Node</span><span class="title">(1</span>)</span><br><span class="line">    child2 = <span class="keyword">Node</span><span class="title">(2</span>)</span><br><span class="line">    root.add_child(child1)</span><br><span class="line">    root.add_child(child2)</span><br><span class="line">    child1.add_child(<span class="keyword">Node</span><span class="title">(3</span>))</span><br><span class="line">    child1.add_child(<span class="keyword">Node</span><span class="title">(4</span>))</span><br><span class="line">    child2.add_child(<span class="keyword">Node</span><span class="title">(5</span>))</span><br><span class="line"></span><br><span class="line">    for ch <span class="keyword">in</span> root.depth_first():</span><br><span class="line">        print(ch)</span><br><span class="line">    <span class="comment"># Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>depth_first()</code> 方法简单直观。它首先返回自己本身并迭代每一个子节点并通过调用子节点的 <code>depth_first()</code> 方法(使用 <code>yield from</code> 语句)返回对应元素。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>Python</code> 的迭代协议要求一个 <code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。 但是，实现这些通常会比较繁琐。下面我们演示下这种方式，如何使用一个关联迭代器类重新实现 <code>depth_first()</code> 方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._value = value</span><br><span class="line">        <span class="keyword">self</span>._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(<span class="keyword">self</span>._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> iter(<span class="keyword">self</span>._children)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth_first</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> DepthFirstIterator(<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstIterator</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    Depth-first traversal</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, start_node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._node = start_node</span><br><span class="line">        <span class="keyword">self</span>._children_iter = None</span><br><span class="line">        <span class="keyword">self</span>._child_iter = None</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># Return myself if just started; create an iterator for children</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>._children_iter is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">self</span>._children_iter = iter(<span class="keyword">self</span>._node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>._node</span><br><span class="line">        <span class="comment"># If processing a child, return its next item</span></span><br><span class="line">        elif <span class="keyword">self</span>.<span class="symbol">_child_iter:</span></span><br><span class="line">            <span class="symbol">try:</span></span><br><span class="line">                nextchild = <span class="keyword">next</span>(<span class="keyword">self</span>._child_iter)</span><br><span class="line">                <span class="keyword">return</span> nextchild</span><br><span class="line">            except <span class="symbol">StopIteration:</span></span><br><span class="line">                <span class="keyword">self</span>._child_iter = None</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">next</span>(<span class="keyword">self</span>)</span><br><span class="line">        <span class="comment"># Advance to the next child and start its iteration</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="keyword">self</span>._child_iter = <span class="keyword">next</span>(<span class="keyword">self</span>._children_iter).depth_first()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">next</span>(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p><code>DepthFirstIterator</code> 类和上面使用生成器的版本工作原理类似，但是它写起来很繁琐，因为迭代器必须在迭代处理过程中维护大量的状态信息。坦白来讲，没人愿意写这么晦涩的代码。将你的迭代器定义为一个生成器后一切迎刃而解。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 迭代器与生成器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4.05 反向迭代</title>
      <link href="/2018-06-08/4-05-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/"/>
      <url>/2018-06-08/4-05-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想反方向迭代一个序列</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用内置的 <code>reversed()</code> 函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> reversed(a):</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>反向迭代仅仅当对象的大小可预先确定或者对象实现了 <code>__reversed__()</code>的特殊方法时才能生效。如果两者都不符合，那你必须先将对象转换为一个列表才行，比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Print a file backwards</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">'somefile'</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> reversed(list(f)):</span><br><span class="line">    print(<span class="built_in">line</span>, <span class="keyword">end</span>=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>要注意的是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>很多程序员并不知道可以通过在自定义类上实现<code>__reversed__()</code>方法来实现反向迭代。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, start)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.start = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        n = <span class="keyword">self</span>.start</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reverse iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &lt;= <span class="keyword">self</span>.<span class="symbol">start:</span></span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> reversed(Countdown(<span class="number">30</span>))<span class="symbol">:</span></span><br><span class="line">    print(rr)</span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> Countdown(<span class="number">30</span>)<span class="symbol">:</span></span><br><span class="line">    print(rr)</span><br></pre></td></tr></table></figure><p>定义一个反向迭代器可以使得代码非常的高效，因为它不再需要将数据填充到一个列表中然后再去反向迭代这个列表。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 迭代器与生成器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.01 读写文本数据</title>
      <link href="/2018-06-08/5-01-%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/"/>
      <url>/2018-06-08/5-01-%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h3 id="第五章：文件与-IO"><a href="#第五章：文件与-IO" class="headerlink" title="第五章：文件与 IO"></a>第五章：文件与 IO</h3><p>所有程序都要处理输入和输出。这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。对文件名和目录的操作也会涉及到。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要读写各种不同编码的文本数据，比如 <code>ASCII</code> ，<code>UTF-8</code> 或 <code>UTF-16</code> 编码等。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用带有 <code>rt</code> 模式的 <code>open()</code> 函数读取文本文件。如下所示：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read the entire file as a single string</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.<span class="built_in">read</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the lines of the file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment"># process line</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>类似的，为了写入一个文本文件，使用带有 <code>wt</code> 模式的 <code>open()</code> 函数，如果之前文件内容存在则清除并覆盖掉。如下所示：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Write chunks of text data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.<span class="built_in">write</span>(text1)</span><br><span class="line">    f.<span class="built_in">write</span>(text2)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redirected print statement</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(line1, <span class="built_in">file</span>=f)</span><br><span class="line">    print(line2, <span class="built_in">file</span>=f)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果是在已存在文件中添加内容，使用模式为 <code>at</code> 的 <code>open()</code> 函数。</p><p>文件的读写操作默认使用系统编码，可以通过调用 <code>sys.getdefaultencoding()</code>来得到。在大多数机器上面都是 <code>utf-8</code> 编码。如果你已经知道你要读写的文本是其他编码方式，那么可以通过传递一个可选的 <code>encoding</code> 参数给 <code>open()</code> 函数。如下所示：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'latin-1'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>Python</code> 支持非常多的文本编码。几个常见的编码是 <code>ascii</code> 、 <code>latin-1</code> 、 <code>utf-8</code> 和 <code>utf-16</code> 。在 <code>web</code> 应用程序中通常都使用的是 <code>UTF-8</code> 。<code>ascii</code> 对应从 <code>U+0000</code> 到 <code>U+007F</code> 范围内的 <code>7</code> 位字符。<code>latin-1</code> 是字节 <code>0-255</code> 到 <code>U+0000</code> 至 <code>U+00FF</code> 范围内 <code>Unicode</code> 字符的直接映射。当读取一个未知编码的文本时使用 <code>latin-1</code>编码永远不会产生解码错误。使用 <code>latin-1</code> 编码读取一个文件的时候也许不能产生完全正确的文本解码数据， 但是它也能从中提取出足够多的有用数据。同时，如果你之后将数据回写回去，原先的数据还是会保留的。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>读写文本文件一般来讲是比较简单的。但是也几点是需要注意的。首先，在例子程序中的 <code>with</code> 语句给被使用到的文件创建了一个上下文环境， 但 <code>with</code> 控制块结束时，文件会自动关闭。你也可以不使用 <code>with</code> 语句，但是这时候你就必须记得手动关闭文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>)</span><br><span class="line">data = f.<span class="built_in">read</span>()</span><br><span class="line">f.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>另外一个问题是关于换行符的识别问题，在 <code>Unix</code> 和 <code>Windows</code> 中是不一样的(分别是 <code>\n</code> 和 <code>\r\n</code> )。 默认情况下，<code>Python</code> 会以统一模式处理换行符。这种模式下，在读取文本的时候， <code>Python</code> 可以识别所有的普通换行符并将其转换为单个 <code>\n</code> 字符。类似的，在输出时会将换行符 <code>\n</code>转换为系统默认的换行符。 如果你不希望这种默认的处理方式，可以给 <code>open()</code> 函数传入参数 <code>newline=&#39;&#39;</code> ，就像下面这样：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Read <span class="keyword">with</span> disabled newline translation</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>为了说明两者之间的差异，下面我在 <code>Unix</code> 机器上面读取一个 <code>Windows</code> 上面的文本文件，里面的内容是 <code>hello world!\r\n</code> ：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Newline translation enabled (the default)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f = open(<span class="string">'hello.txt'</span>, <span class="string">'rt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f.read()</span><br><span class="line"><span class="string">'hello world!\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Newline translation disabled</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g = open(<span class="string">'hello.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g.read()</span><br><span class="line"><span class="string">'hello world!\r\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>最后一个问题就是文本文件中可能出现的编码错误。但你读取或者写入一个文本文件时，你可能会遇到一个编码或者解码错误。比如：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = <span class="keyword">open</span>(<span class="symbol">'sample</span>.txt', <span class="symbol">'rt</span>', encoding=<span class="symbol">'ascii</span>')</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="literal">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.3/encodings/ascii.py"</span>, <span class="literal">line</span> <span class="number">26</span>, <span class="keyword">in</span> decode</span><br><span class="line">        <span class="keyword">return</span> codecs.ascii_decode(input, self.errors)[<span class="number">0</span>]</span><br><span class="line">UnicodeDecodeError: <span class="symbol">'ascii</span>' codec can<span class="symbol">'t</span> decode byte <span class="number">0</span>xc3 <span class="keyword">in</span> position</span><br><span class="line"><span class="number">12</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">128</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果出现这个错误，通常表示你读取文本时指定的编码不正确。你最好仔细阅读说明并确认你的文件编码是正确的（比如使用 <code>UTF-8</code> 而不是 <code>Latin-1</code> 编码或其他）。如果编码错误还是存在的话，你可以给 <code>open()</code> 函数传递一个可选的 <code>errors</code> 参数来处理这些错误。下面是一些处理常见错误的方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Replace bad chars with Unicode U+fffd replacement char</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f = open(<span class="string">'sample.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'ascii'</span>, errors=<span class="string">'replace'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f.read()</span><br><span class="line"><span class="string">'Spicy Jalape?o!'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Ignore bad chars entirely</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g = open(<span class="string">'sample.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'ascii'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g.read()</span><br><span class="line"><span class="string">'Spicy Jalapeo!'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你经常使用 <code>errors</code> 参数来处理编码错误，可能会让你的生活变得很糟糕。对于文本处理的首要原则是确保你总是使用的是正确编码。当模棱两可的时候，就使用默认的设置（通常都是 <code>UTF-8</code> ）。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 文件与 IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.02 打印输出至文件中</title>
      <link href="/2018-06-08/5-02-%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E8%87%B3%E6%96%87%E4%BB%B6%E4%B8%AD/"/>
      <url>/2018-06-08/5-02-%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E8%87%B3%E6%96%87%E4%BB%B6%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想将 <code>print()</code> 函数的输出重定向到一个文件中去。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 <code>print()</code> 函数中指定 <code>file</code> 关键字参数，像下面这样：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'d:/work/test.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'Hello World!'</span>, <span class="built_in">file</span>=f)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>关于输出重定向到文件中就这些了。但是有一点要注意的就是文件必须是以文本模式打开。 如果文件是二进制模式的话，打印就会出错。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 文件与 IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.03 使用其他分隔符或行终止符打印</title>
      <link href="/2018-06-08/5-03-%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%88%86%E9%9A%94%E7%AC%A6%E6%88%96%E8%A1%8C%E7%BB%88%E6%AD%A2%E7%AC%A6%E6%89%93%E5%8D%B0/"/>
      <url>/2018-06-08/5-03-%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%88%86%E9%9A%94%E7%AC%A6%E6%88%96%E8%A1%8C%E7%BB%88%E6%AD%A2%E7%AC%A6%E6%89%93%E5%8D%B0/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想使用 <code>print()</code> 函数输出数据，但是想改变默认的分隔符或者行尾符。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以使用在 <code>print()</code> 函数中使用 <code>sep</code> 和 <code>end</code> 关键字参数，以你想要的方式输出。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'ACME'</span>, 50, 91.5)</span></span><br><span class="line">ACME 50 91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'ACME'</span>, 50, 91.5, sep=<span class="string">','</span>)</span></span><br><span class="line">ACME,50,91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'ACME'</span>, 50, 91.5, sep=<span class="string">','</span>, end=<span class="string">'!!\n'</span>)</span></span><br><span class="line">ACME,50,91.5!!</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>end</code> 参数也可以在输出中禁止换行。比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line"><span class="built_in">..</span>.     <span class="builtin-name">print</span>(i)</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line"><span class="built_in">..</span>.     <span class="builtin-name">print</span>(i, <span class="attribute">end</span>=<span class="string">' '</span>)</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">0 1 2 3 4 &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>当你想使用非空格分隔符来输出数据的时候，给 <code>print()</code> 函数传递一个 <code>sep</code> 参数是最简单的方案。有时候你会看到一些程序员会使用 <code>str.join()</code> 来完成同样的事情。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">','</span>.join((<span class="string">'ACME'</span>,<span class="string">'50'</span>,<span class="string">'91.5'</span>)))</span></span><br><span class="line">ACME,50,91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><code>str.join()</code> 的问题在于它仅仅适用于字符串。这意味着你通常需要执行另外一些转换才能让它正常工作。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; row = (<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">','</span>.join(row))</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> sequence item <span class="number">1</span>: expected str instance, int found</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">','</span>.join(str(x) for x in row))</span><br><span class="line">ACME,<span class="number">50</span>,<span class="number">91.5</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>你当然可以不用那么麻烦，只需要像下面这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(*row, sep=<span class="string">','</span>)</span></span><br><span class="line">ACME,50,91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 文件与 IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.04 读写字节数据问题</title>
      <link href="/2018-06-08/5-04-%E8%AF%BB%E5%86%99%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2018-06-08/5-04-%E8%AF%BB%E5%86%99%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想读写二进制文件，比如图片，声音文件等等。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用模式为 <code>rb</code> 或 <code>wb</code> 的 <code>open()</code> 函数来读取或写入二进制数据。比如：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Read</span> the entire <span class="keyword">file</span> <span class="keyword">as</span> a single byte <span class="keyword">string</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.<span class="keyword">read</span>()</span><br><span class="line"></span><br><span class="line"># <span class="keyword">Write</span> binary data <span class="keyword">to</span> a <span class="keyword">file</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.<span class="keyword">write</span>(b<span class="string">'Hello World'</span>)</span><br></pre></td></tr></table></figure><p>在读取二进制数据时，需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串。类似的，在写入的时候，必须保证参数是以字节形式对外暴露数据的对象（比如字节字符串，字节数组对象等）。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>在读取二进制数据的时候，字节字符串和文本字符串的语义差异可能会导致一个潜在的陷阱。 特别需要注意的是，索引和迭代动作返回的是字节的值而不是字节字符串。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Text string</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t = <span class="string">'Hello World'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t[0]</span></span><br><span class="line">'H'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> c <span class="keyword">in</span> t:</span></span><br><span class="line">...     print(c)</span><br><span class="line">...</span><br><span class="line">H</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Byte string</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = b<span class="string">'Hello World'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b[0]</span></span><br><span class="line">72</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> c <span class="keyword">in</span> b:</span></span><br><span class="line">...     print(c)</span><br><span class="line">...</span><br><span class="line">72</span><br><span class="line">101</span><br><span class="line">108</span><br><span class="line">108</span><br><span class="line">111</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想从二进制模式的文件中读取或写入文本数据，必须确保要进行解码和编码操作。比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.<span class="built_in">read</span>(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">text</span> = data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">text</span> = <span class="string">'Hello World'</span></span><br><span class="line">    f.<span class="built_in">write</span>(<span class="keyword">text</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>二进制 <code>I/O</code> 还有一个鲜为人知的特性就是数组和 <code>C</code> 结构体类型能直接被写入，而不需要中间转换为自己对象。比如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import array</span><br><span class="line">nums = array.array('i', [1, 2, 3, 4])</span><br><span class="line">with open('data.bin','wb') as f:</span><br><span class="line">    f.write(nums)</span><br></pre></td></tr></table></figure><p>这个适用于任何实现了被称之为 缓冲接口的对象，这种对象会直接暴露其底层的内存缓冲区给能处理它的操作。二进制数据的写入就是这类操作之一。</p><p>很多对象还允许通过使用文件对象的 <code>readinto()</code> 方法直接读取二进制数据到其底层的内存中去。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import array</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = array.array(<span class="string">'i'</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; with open(<span class="string">'data.bin'</span>, <span class="string">'rb'</span>) as <span class="symbol">f:</span></span><br><span class="line">...     f.readinto(a)</span><br><span class="line">...</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line">array(<span class="string">'i'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>但是使用这种技术的时候需要格外小心，因为它通常具有平台相关性，并且可能会依赖字长和字节顺序（高位优先和低位优先）。可以查看 <code>5.9小节</code> 中另外一个读取二进制数据到可修改缓冲区的例子。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 文件与 IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.05 文件不存在才能写入</title>
      <link href="/2018-06-08/5-05-%E6%96%87%E4%BB%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%89%8D%E8%83%BD%E5%86%99%E5%85%A5/"/>
      <url>/2018-06-08/5-05-%E6%96%87%E4%BB%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%89%8D%E8%83%BD%E5%86%99%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想向一个文件中写入数据，但是前提必须是这个文件在文件系统上不存在。也就是不允许覆盖已存在的文件内容。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以在 <code>open()</code> 函数中使用x模式来代替w模式的方法来解决这个问题。比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">...     f.<span class="built_in">write</span>(<span class="string">'Hello\n'</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile'</span>, <span class="string">'xt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">...     f.<span class="built_in">write</span>(<span class="string">'Hello\n'</span>)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">FileExistsError: [Errno <span class="number">17</span>] File exists: <span class="string">'somefile'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果文件是二进制的，使用 <code>xb</code> 来代替 <code>xt</code> </p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>这一小节演示了在写文件时通常会遇到的一个问题的完美解决方案（不小心覆盖一个已存在的文件）。 一个替代方案是先测试这个文件是否存在，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'somefile'</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">with</span> open(<span class="string">'somefile'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>        f.write(<span class="string">'Hello\n'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'File already exists!'</span>)</span><br><span class="line">...</span><br><span class="line">File already exists!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>显而易见，使用x文件模式更加简单。要注意的是 <code>x</code> 模式是一个 <code>Python3</code> 对 <code>open()</code> 函数特有的扩展。在 <code>Python</code> 的旧版本或者是 <code>Python</code> 实现的底层 <code>C</code> 函数库中都是没有这个模式的。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 文件与 IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.01 读写 CSV 数据</title>
      <link href="/2018-06-08/6-01-%E8%AF%BB%E5%86%99-CSV-%E6%95%B0%E6%8D%AE/"/>
      <url>/2018-06-08/6-01-%E8%AF%BB%E5%86%99-CSV-%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h3 id="第六章：数据编码和处理"><a href="#第六章：数据编码和处理" class="headerlink" title="第六章：数据编码和处理"></a>第六章：数据编码和处理</h3><p>这一章主要讨论使用 <code>Python</code> 处理各种不同方式编码的数据，比如 <code>CSV</code> 文件， <code>JSON</code> ， <code>XML</code> 和二进制包装记录。和数据结构那一章不同的是，这章不会讨论特殊的算法问题，而是关注于怎样获取和存储这些格式的数据。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想读写一个 <code>CSV</code> 格式的文件。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于大多数的 <code>CSV</code> 格式的数据读写问题，都可以使用 <code>csv</code> 库。例如：假设你在一个名叫 <code>stocks.csv</code> 文件中有一些股票市场数据，就像这样：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol,Price,Date,Time,Change,Volume</span><br><span class="line"><span class="string">"AA"</span>,<span class="number">39.48</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.18</span>,<span class="number">181800</span></span><br><span class="line"><span class="string">"AIG"</span>,<span class="number">71.38</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.15</span>,<span class="number">195500</span></span><br><span class="line"><span class="string">"AXP"</span>,<span class="number">62.58</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.46</span>,<span class="number">935000</span></span><br><span class="line"><span class="string">"BA"</span>,<span class="number">98.31</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,+<span class="number">0.12</span>,<span class="number">104800</span></span><br><span class="line"><span class="string">"C"</span>,<span class="number">53.08</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.25</span>,<span class="number">360900</span></span><br><span class="line"><span class="string">"CAT"</span>,<span class="number">78.29</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.23</span>,<span class="number">225400</span></span><br></pre></td></tr></table></figure><p>下面向你展示如何将这些数据读取为一个元组的序列：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    for row <span class="keyword">in</span> f_csv:</span><br><span class="line">        # Process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在上面的代码中， <code>row</code> 会是一个列表。因此，为了访问某个字段，你需要使用下标，如 <code>row[0]</code>访问 <code>Symbol，row[4]</code> 访问 <code>Change</code> 。</p><p>由于这种下标访问通常会引起混淆，你可以考虑使用命名元组。例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stock.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headings = next(f_csv)</span><br><span class="line">    Row = namedtuple(<span class="string">'Row'</span>, headings)</span><br><span class="line">    for r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        # Process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>它允许你使用列名如 <code>row.Symbol</code> 和 <code>row.Change</code> 代替下标访问。需要注意的是这个只有在列名是合法的 <code>Python</code> 标识符的时候才生效。如果不是的话，你可能需要修改下原始的列名（如将非标识符字符替换成下划线之类的）。</p><p>另外一个选择就是将数据读取到一个字典序列中去。可以这样做：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictReader(f)</span><br><span class="line">    for row <span class="keyword">in</span> f_csv:</span><br><span class="line">        # process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在这个版本中，你可以使用列名去访问每一行的数据了。比如，<code>row[&#39;Symbol&#39;]</code> 或者 <code>row[&#39;Change&#39;]</code></p><p>为了写入 <code>CSV</code> 数据，你仍然可以使用 <code>csv</code> 模块，不过这时候先创建一个 <code>writer</code> 对象。例如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">headers = ['Symbol','Price','Date','Time','Change','Volume']</span><br><span class="line">rows = [('AA', <span class="number">39.48</span>, '6/11/<span class="number">2007</span>', '9:36am', -<span class="number">0.18</span>, <span class="number">181800</span>),</span><br><span class="line">         ('AIG', <span class="number">71.38</span>, '6/11/<span class="number">2007</span>', '9:36am', -<span class="number">0.15</span>, <span class="number">195500</span>),</span><br><span class="line">         ('AXP', <span class="number">62.58</span>, '6/11/<span class="number">2007</span>', '9:36am', -<span class="number">0.46</span>, <span class="number">935000</span>),</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line">with open('stocks.csv','w') as f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure><p>如果你有一个字典序列的数据，可以像这样做：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">'Symbol'</span>, <span class="string">'Price'</span>, <span class="string">'Date'</span>, <span class="string">'Time'</span>, <span class="string">'Change'</span>, <span class="string">'Volume'</span>]</span><br><span class="line">rows = [&#123;<span class="string">'Symbol'</span>:<span class="string">'AA'</span>, <span class="string">'Price'</span>:<span class="number">39.48</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:-<span class="number">0.18</span>, <span class="string">'Volume'</span>:<span class="number">181800</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AIG'</span>, <span class="string">'Price'</span>: <span class="number">71.38</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:-<span class="number">0.15</span>, <span class="string">'Volume'</span>: <span class="number">195500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AXP'</span>, <span class="string">'Price'</span>: <span class="number">62.58</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:-<span class="number">0.46</span>, <span class="string">'Volume'</span>: <span class="number">935000</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">with open(<span class="string">'stocks.csv'</span>,<span class="string">'w'</span>) as f:</span><br><span class="line">    f_csv = csv.<span class="symbol">DictWriter</span>(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>你应该总是优先选择 <code>csv</code> 模块分割或解析 <code>CSV</code> 数据。</p><p>例如，你可能会像编写类似下面这样的代码：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">    row = <span class="built_in">line</span>.<span class="built_in">split</span>(<span class="string">','</span>)</span><br><span class="line">    <span class="comment"># process row</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用这种方式的一个缺点就是你仍然需要去处理一些棘手的细节问题。比如，如果某些字段值被引号包围，你不得不去除这些引号。另外，如果一个被引号包围的字段碰巧含有一个逗号，那么程序就会因为产生一个错误大小的行而出错。</p><p>默认情况下， <code>csv</code> 库可识别 <code>Microsoft Excel</code> 所使用的 <code>CSV</code> 编码规则。这或许也是最常见的形式，并且也会给你带来最好的兼容性。然而，如果你查看 <code>csv</code> 的文档，就会发现有很多种方法将它应用到其他编码格式上（如修改分割字符等）。 例如，如果你想读取以 <code>tab</code> 分割的数据，可以这样做：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Example <span class="keyword">of</span> reading tab-separated values</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stock.tsv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_tsv = csv.reader(f, delimiter=<span class="string">'\t'</span>)</span><br><span class="line">    for row <span class="keyword">in</span> f_tsv:</span><br><span class="line">        # Process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>如果你正在读取 <code>CSV</code> 数据并将它们转换为命名元组，需要注意对列名进行合法性认证。例如，一个 <code>CSV</code> 格式文件有一个包含非法标识符的列头行，类似下面这样：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Street Address,Num-Premises,Latitude,Longitude <span class="number">5412</span> N CLARK,<span class="number">10</span>,<span class="number">41.980262</span>,<span class="number">-87.668452</span></span><br></pre></td></tr></table></figure><p>这样最终会导致在创建一个命名元组时产生一个 <code>ValueError</code> 异常而失败。 为了解决这问题，你可能不得不先去修正列标题。例如，可以像下面这样在非法标识符上使用一个正则表达式替换：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"><span class="function">with <span class="title">open</span>(<span class="params"><span class="string">'stock.csv'</span></span>) <span class="keyword">as</span> f:</span></span><br><span class="line"><span class="function">    f_csv </span>= csv.reader(f)</span><br><span class="line">    headers = [ re.sub(<span class="string">'[^a-zA-Z_]'</span>, <span class="string">'_'</span>, h) <span class="function"><span class="keyword">for</span> h <span class="keyword">in</span> <span class="title">next</span>(<span class="params">f_csv</span>) ]</span></span><br><span class="line"><span class="function">    Row </span>= namedtuple(<span class="string">'Row'</span>, headers)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        <span class="meta"># Process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>还有重要的一点需要强调的是， <code>csv</code> 产生的数据都是字符串类型的，它不会做任何其他类型的转换。如果你需要做这样的类型转换，你必须自己手动去实现。下面是一个在 <code>CSV</code> 数据上执行其他类型转换的例子：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">col_types = [str, float, str, str, float, int]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        <span class="comment"># Apply conversions to the row items</span></span><br><span class="line">        row = tuple(<span class="built_in">convert</span>(<span class="built_in">value</span>) <span class="keyword">for</span> <span class="built_in">convert</span>, <span class="built_in">value</span> <span class="keyword">in</span> zip(col_types, row))</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>另外，下面是一个转换字典中特定字段的例子：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="symbol">'Reading</span> <span class="keyword">as</span> dicts <span class="keyword">with</span> <span class="keyword">type</span> conversion')</span><br><span class="line">field_types = [ (<span class="symbol">'Price'</span>, <span class="built_in">float</span>),</span><br><span class="line">                (<span class="symbol">'Change'</span>, <span class="built_in">float</span>),</span><br><span class="line">                (<span class="symbol">'Volume'</span>, <span class="built_in">int</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">'stocks</span>.csv') <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv.<span class="type">DictReader</span>(f):</span><br><span class="line">        row.update((key, conversion(row[key]))</span><br><span class="line">                <span class="keyword">for</span> key, conversion <span class="keyword">in</span> field_types)</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><p>通常来讲，你可能并不想过多去考虑这些转换问题。 在实际情况中， <code>CSV</code> 文件都或多或少有些缺失的数据，被破坏的数据以及其它一些让转换失败的问题。因此，除非你的数据确实有保障是准确无误的，否则你必须考虑这些问题（你可能需要增加合适的错误处理机制）。</p><p>最后，如果你读取 <code>CSV</code> 数据的目的是做数据分析和统计的话， 你可能需要看一看 <code>Pandas</code> 包。 <code>Pandas</code> 包含了一个非常方便的函数叫 <code>pandas.read_csv()</code> ，它可以加载 <code>CSV</code> 数据到一个 <code>DataFrame</code> 对象中去 。 然后利用这个对象你就可以生成各种形式的统计、过滤数据以及执行其他高级操作了。 在 <code>6.13 小节</code> 中会有这样一个例子。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据编码和处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.02 读写 JSON 数据</title>
      <link href="/2018-06-08/6-02-%E8%AF%BB%E5%86%99-JSON-%E6%95%B0%E6%8D%AE/"/>
      <url>/2018-06-08/6-02-%E8%AF%BB%E5%86%99-JSON-%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想读写 <code>JSON(JavaScript Object Notation)</code> 编码格式的数据。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>json</code> 模块提供了一种很简单的方式来编码和解码 <code>JSON</code> 数据。 其中两个主要的函数是 <code>json.dumps()</code> 和 <code>json.loads()</code> ，要比其他序列化函数库如 <code>pickle</code> 的接口少得多。 下面演示如何将一个 <code>Python</code> 数据结构转换为 <code>JSON</code> ：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> = &#123;</span></span><br><span class="line"><span class="class">    '<span class="title">name'</span> : '<span class="type">ACME</span>',</span></span><br><span class="line"><span class="class">    '<span class="title">shares'</span> : 100,</span></span><br><span class="line"><span class="class">    '<span class="title">price'</span> : 542.23</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="title">json_str</span> = json.dumps(<span class="class"><span class="keyword">data</span>)</span></span><br></pre></td></tr></table></figure><p>下面演示如何将一个 <code>JSON</code> 编码的字符串转换回一个 <code>Python</code> 数据结构：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = json.loads(<span class="title">json_str</span>)</span></span><br></pre></td></tr></table></figure><p>如果你要处理的是文件而不是字符串，你可以使用 <code>json.dump()</code> 和 <code>json.load()</code> 来编码和解码 <code>JSON</code> 数据。例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing JSON data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading data back</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'data.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.<span class="built_in">load</span>(f)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>JSON</code> 编码支持的基本数据类型为 <code>None ， bool ， int ， float</code> 和 <code>str</code> ，以及包含这些类型数据的 <code>lists</code> ，<code>tuples</code> 和 <code>dictionaries</code> 。对于 <code>dictionaries</code> ， <code>keys</code> 需要是字符串类型(字典中任何非字符串类型的 key 在编码时会先转换为字符串)。为了遵循 <code>JSON</code> 规范，你应该只编码 <code>Python</code> 的 <code>lists</code> 和 <code>dictionaries</code> 。而且，在 <code>web</code> 应用程序中，顶层对象被编码为一个字典是一个标准做法。</p><p><code>JSON</code> 编码的格式对于 <code>Python</code> 语法而已几乎是完全一样的，除了一些小的差异之外。比如， <code>True</code> 会被映射为 <code>true</code> ， <code>False</code> 被映射为 <code>false</code> ，而 <code>None</code> 会被映射为 <code>null</code> 。 下面是一个例子，演示了编码后的字符串效果：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(False)</span><br><span class="line"><span class="string">'false'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d = &#123;<span class="string">'a'</span>: True,</span><br><span class="line">...     <span class="string">'b'</span>: <span class="string">'Hello'</span>,</span><br><span class="line">...     <span class="string">'c'</span>: None&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"b": "Hello", "c": null, "a": true&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你试着去检查 <code>JSON</code> 解码后的数据，你通常很难通过简单的打印来确定它的结构，特别是当数据的嵌套结构层次很深或者包含大量的字段时。为了解决这个问题，可以考虑使用 <code>pprint</code> 模块的 <code>pprint()</code> 函数来代替普通的 <code>print()</code> 函数。它会按照 <code>key</code> 的字母顺序并以一种更加美观的方式输出。下面是一个演示如何漂亮的打印输出 <code>Twitter</code> 上搜索结果的例子：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib.request import urlopen</span><br><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; u = urlopen('http://search.twitter.com/search.json?q=python&amp;rpp=5')</span><br><span class="line">&gt;&gt;&gt; resp = json.loads(u.read().decode('utf-8'))</span><br><span class="line">&gt;&gt;&gt; from pprint import pprint</span><br><span class="line">&gt;&gt;&gt; pprint(resp)</span><br><span class="line">&#123;'completed_in': <span class="number">0.074</span>,</span><br><span class="line">'max_id': <span class="number">264043230692245504</span>,</span><br><span class="line">'max_id_str': '<span class="number">26404323069224</span><span class="number">5504</span>',</span><br><span class="line">'next_page': '?page=2&amp;max_id=<span class="number">26404323069224</span><span class="number">5504</span>&amp;q=python&amp;rpp=5',</span><br><span class="line">'page': <span class="number">1</span>,</span><br><span class="line">'query': 'python',</span><br><span class="line">'refresh_url': '?since_id=<span class="number">26404323069224</span><span class="number">5504</span>&amp;q=python',</span><br><span class="line">'results': [&#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:26 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:14 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:13 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:07 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:04 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;],</span><br><span class="line">'results_per_page': <span class="number">5</span>,</span><br><span class="line">'since_id': <span class="number">0</span>,</span><br><span class="line">'since_id_str': '0'&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>一般来讲， <code>JSON</code> 解码会根据提供的数据创建 <code>dicts</code> 或 <code>lists</code> 。如果你想要创建其他类型的对象，可以给 <code>json.loads()</code> 传递 <code>object_pairs_hook</code> 或 <code>object_hook</code> 参数。例如，下面是演示如何解码 <code>JSON</code> 数据并在一个 <code>OrderedDict</code> 中保留其顺序的例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'&#123;"name": "ACME", "shares": 50, "price": 490.1&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from collections import OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = json.loads(s, object_pairs_hook=OrderedDict)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'ACME'</span>), (<span class="string">'shares'</span>, <span class="number">50</span>), (<span class="string">'price'</span>, <span class="number">490.1</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>下面是如何将一个 <code>JSON</code> 字典转换为一个 <code>Python</code> 对象例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">JSONObject</span>:</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, d)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">self</span>.__dict_<span class="number">_</span> = d</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = json.loads(s, object_hook=JSONObject)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data.name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data.shares</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data.price</span><br><span class="line"><span class="number">490.1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>最后一个例子中， <code>JSON</code> 解码后的字典作为一个单个参数传递给 <code>__init__()</code> 。 然后，你就可以随心所欲的使用它了，比如作为一个实例字典来直接使用它。</p><p>在编码 <code>JSON</code> 的时候，还有一些选项很有用。如果你想获得漂亮的格式化字符串后输出，可以使用 <code>json.dumps()</code> 的 <code>indent</code> 参数。它会使得输出和 <code>pprint()</code> 函数效果类似。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(json.dumps(data))</span><br><span class="line">&#123;<span class="string">"price"</span>: <span class="number">542.23</span>, <span class="string">"name"</span>: <span class="string">"ACME"</span>, <span class="string">"shares"</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(json.dumps(data, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"price"</span>: <span class="number">542.23</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ACME"</span>,</span><br><span class="line">    <span class="string">"shares"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>对象实例通常并不是 <code>JSON</code> 可序列化的。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, x, y)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">self</span>.x = x</span><br><span class="line">...         <span class="keyword">self</span>.y = y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(p)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/__init__.py"</span>, line <span class="number">226</span>, <span class="keyword">in</span> dumps</span><br><span class="line">        <span class="keyword">return</span> _default_encoder.encode(obj)</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="number">187</span>, <span class="keyword">in</span> encode</span><br><span class="line">        chunks = <span class="keyword">self</span>.iterencode(o, _one_shot=True)</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="number">245</span>, <span class="keyword">in</span> iterencode</span><br><span class="line">        <span class="keyword">return</span> _iterencode(o, <span class="number">0</span>)</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="number">169</span>, <span class="keyword">in</span> default</span><br><span class="line">        raise TypeError(repr(o) + <span class="string">" is not JSON serializable"</span>)</span><br><span class="line"><span class="symbol">TypeError:</span> &lt;__main_<span class="number">_</span>.Point object at <span class="number">0x1006f2650</span>&gt; is <span class="keyword">not</span> JSON serializable</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想序列化对象实例，你可以提供一个函数，它的输入是一个实例，返回一个可序列化的字典。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize_instance</span></span>(obj):</span><br><span class="line">    d = &#123; <span class="symbol">'__classname_</span>_' : <span class="class"><span class="keyword">type</span>(<span class="params">obj</span>).<span class="title">__name__</span> &#125;</span></span><br><span class="line"><span class="class">    <span class="title">d</span>.<span class="title">update</span>(<span class="params">vars(obj</span>))</span></span><br><span class="line"><span class="class">    <span class="title">return</span> <span class="title">d</span></span></span><br></pre></td></tr></table></figure><p>如果你想反过来获取这个实例，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionary mapping names to known classes</span></span><br><span class="line">classes = &#123;</span><br><span class="line">    <span class="string">'Point'</span> : Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unserialize_object</span><span class="params">(d)</span>:</span></span><br><span class="line">    clsname = d.pop(<span class="string">'__classname__'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> clsname:</span><br><span class="line">        cls = classes[clsname]</span><br><span class="line">        obj = cls.__new__(cls) <span class="comment"># Make instance without calling __init__</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            setattr(obj, key, value)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure><p>下面是如何使用这些函数的例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">p</span> = Point(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; s = json.dumps(<span class="selector-tag">p</span>, default=serialize_instance)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line"><span class="string">'&#123;"__classname__": "Point", "y": 3, "x": 2&#125;'</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = json.loads(s, object_hook=unserialize_object)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;__main__<span class="selector-class">.Point</span> <span class="selector-tag">object</span> at <span class="number">0</span>x1017577d0&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.y</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>json</code> 模块还有很多其他选项来控制更低级别的数字、特殊值如 <code>NaN</code> 等的解析。<br>可以参考官方文档获取更多细节 。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据编码和处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.01 解压序列赋值给多个变量</title>
      <link href="/2018-06-08/1-01-%E8%A7%A3%E5%8E%8B%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2018-06-08/1-01-%E8%A7%A3%E5%8E%8B%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h3 id="第一章：数据结构和算法"><a href="#第一章：数据结构和算法" class="headerlink" title="第一章：数据结构和算法"></a>第一章：数据结构和算法</h3><p><code>Python</code> 提供了大量的内置数据结构，包括列表，集合以及字典。大多数情况下使用这些数据结构是很简单的。但是，我们也会经常碰到到诸如查询，排序和过滤等等这些普遍存在的问题。因此，这一章的目的就是讨论这些比较常见的问题和算法。另外，我们也会给出在集合模块 <code>collections</code> 当中操作这些数据结构的方法。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>现在有一个包含 <code>N</code> 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 <code>N</code> 个变量 ？</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。唯一的前提就是变量的数量必须跟序列元素的数量是一样的。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x, y = p</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; y</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = [ <span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, shares, price, date = data</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; date</span><br><span class="line">(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, shares, price, (year, mon, day) = data</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; year</span><br><span class="line"><span class="number">2012</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; mon</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; day</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果变量个数和序列元素的个数不匹配，会产生一个异常。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x, y, z = p</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">ValueError:</span> need more than <span class="number">2</span> values to unpack</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>实际上，这种解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或者元组。 包括字符串，文件对象，迭代器和生成器。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a, b, c, d, e = s</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line"><span class="string">'H'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; e</span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>有时候，你可能只想解压一部分，丢弃其他的值。对于这种情况 <code>Python</code> 并没有提供特殊的语法。但是你可以使用任意变量名去占位，到时候丢掉这些变量就行了。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = [ <span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="number">_</span>, shares, price, <span class="number">_</span> = data</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; shares</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; price</span><br><span class="line"><span class="number">91.1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>你必须保证你选用的那些占位变量名在其他地方没被使用到。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.02 解压可迭代对象赋值给多个变量</title>
      <link href="/2018-06-08/1-02-%E8%A7%A3%E5%8E%8B%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2018-06-08/1-02-%E8%A7%A3%E5%8E%8B%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 <code>ValueError</code> 。 那么怎样才能从这个可迭代对象中解压出 <code>N</code> 个元素出来？</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>Python</code> 的星号表达式可以用来解决这个问题。比如，你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是排除掉第一个和最后一个分数。如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有 <code>24</code> 个呢？这时候星号表达式就派上用场了：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def drop_first_last(grades):</span><br><span class="line">    <span class="keyword">first</span>, *<span class="keyword">middle</span>, <span class="keyword">last</span> = grades</span><br><span class="line">    <span class="literal">return</span> <span class="built_in">avg</span>(<span class="keyword">middle</span>)</span><br></pre></td></tr></table></figure><p>另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 你可以像下面这样分解这些记录：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; record = (<span class="string">'Dave'</span>, <span class="string">'dave@example.com'</span>, <span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, email, *phone_numbers = record</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'Dave'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; email</span><br><span class="line"><span class="string">'dave@example.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; phone_numbers</span><br><span class="line">[<span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>值得注意的是上面解压出的 <code>phone_numbers</code> 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 <code>0</code> 个）。 所以，任何使用到 <code>phone_numbers</code> 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。</p><p>星号表达式也能用在列表的开始部分。比如，你有一个公司前 <code>8</code> 个月销售数据的序列，但是你想看下最近一个月数据和前面 <code>7</code> 个月的平均值的对比。你可以这样做：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*trailing_qtrs, current_qtr = sales_record</span><br><span class="line">trailing_avg = <span class="built_in">sum</span>(trailing_qtrs) / <span class="built_in">len</span>(trailing_qtrs)</span><br><span class="line"><span class="literal">return</span> avg_comparison(trailing_avg, current_qtr)</span><br></pre></td></tr></table></figure><p>下面是在 <code>Python</code> 解释器中执行的结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; *trailing, current = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; trailing</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">&gt;&gt;&gt; current</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。通常，这些可迭代对象的元素结构有确定的规则（比如第 <code>1</code> 个元素后面都是电话号码），星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。而不是通过一些比较复杂的手段去获取这些关联的元素值。</p><p>值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。 比如，下面是一个带有标签的元组序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">records = [</span><br><span class="line">    (<span class="string">'foo'</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">'bar'</span>, <span class="string">'hello'</span>),</span><br><span class="line">    (<span class="string">'foo'</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_foo</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'foo'</span>, x, y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_bar</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">'bar'</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tag, *args <span class="keyword">in</span> records:</span><br><span class="line">    <span class="keyword">if</span> tag == <span class="string">'foo'</span>:</span><br><span class="line">        do_foo(*args)</span><br><span class="line">    <span class="keyword">elif</span> tag == <span class="string">'bar'</span>:</span><br><span class="line">        do_bar(*args)</span><br></pre></td></tr></table></figure><p>星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; line = <span class="string">'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; uname, *fields, homedir, sh = line.split(<span class="string">':'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; uname</span><br><span class="line"><span class="string">'nobody'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; homedir</span><br><span class="line"><span class="string">'/var/empty'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sh</span><br><span class="line"><span class="string">'/usr/bin/false'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>有时候，你想解压一些元素后丢弃它们，你不能简单就使用<code>*</code>，但是你可以使用一个普通的废弃名称，比如 <code>_</code> 或者 <code>ign （ignore）</code>。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; record = (<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">123.45</span>, (<span class="number">12</span>, <span class="number">18</span>, <span class="number">2012</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, *<span class="number">_</span>, (*<span class="number">_</span>, year) = record</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; year</span><br><span class="line"><span class="number">2012</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。比如，如果你有一个列表，你可以很容易的将它分割成前后两部分：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; items = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt; head, *tail = items</span><br><span class="line">&gt;&gt;&gt; head</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; tail</span><br><span class="line">[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(items)</span></span><span class="symbol">:</span></span><br><span class="line">...     head, *tail = items</span><br><span class="line">...     <span class="keyword">return</span> head + sum(tail) <span class="keyword">if</span> tail <span class="keyword">else</span> head</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sum(items)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>然后，由于语言层面的限制，递归并不是 <code>Python</code> 擅长的。因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.03 保留最后 N 个元素</title>
      <link href="/2018-06-08/1-03-%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E-N-%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2018-06-08/1-03-%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E-N-%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>保留有限历史记录正是 <code>collections.deque</code> 大显身手的时候。</p><p>比如，下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(lines, pattern, history=<span class="number">5</span>)</span>:</span></span><br><span class="line">    previous_lines = deque(maxlen=history)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">yield</span> line, previous_lines</span><br><span class="line">        previous_lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use on a file</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r'../../cookbook/somefile.txt'</span>,<span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line, prevlines <span class="keyword">in</span> search(f, <span class="string">'python'</span>, <span class="number">5</span>):</span><br><span class="line">            <span class="keyword">for</span> pline <span class="keyword">in</span> prevlines:</span><br><span class="line">                print(pline, end=<span class="string">''</span>)</span><br><span class="line">            print(line, end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">'-'</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>我们在写查询元素的代码时，通常会使用包含 <code>yield</code> 表达式的生成器函数，也就是我们上面示例代码中的那样。这样可以将搜索过程代码和使用搜索结果代码解耦。</p><p>使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候，最老的元素会自动被移除掉。</p><p>代码示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span> = deque(maxlen=<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">3</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">3</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><p>尽管你也可以手动在一个列表上实现这一的操作（比如增加、删除等等）。但是这里的队列方案会更加优雅并且运行得更快些。</p><p>更一般的， <code>deque</code> 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p><p>代码示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span> = deque()</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.appendleft(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.popleft()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>在队列两端插入或删除元素时间复杂度都是 <code>O(1)</code> ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 <code>O(N)</code> 。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.04 查找最大或最小的 N 个元素</title>
      <link href="/2018-06-08/1-04-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E6%88%96%E6%9C%80%E5%B0%8F%E7%9A%84-N-%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2018-06-08/1-04-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E6%88%96%E6%9C%80%E5%B0%8F%E7%9A%84-N-%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样从一个集合中获得最大或者最小的 <code>N</code> 个元素列表？<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>heapq</code> 模块有两个函数：<code>nlargest()</code> 和 <code>nsmallest()</code> 可以完美解决这个问题。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums)) # Prints [<span class="number">42</span>, <span class="number">37</span>, <span class="number">23</span>]</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums)) # Prints [<span class="number">-4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>两个函数都能接受一个关键字参数，用于更复杂的数据结构中：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=lambda s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=lambda s: s[<span class="string">'price'</span>])</span><br></pre></td></tr></table></figure><p>译者注：上面代码在对每个元素进行对比的时候，会以 <code>price</code> 的值进行比较。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>如果你想在一个集合中查找最小或最大的 <code>N</code> 个元素，并且 <code>N</code> 小于集合元素数量，那么这些函数提供了很好的性能。因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt; import heapq</span><br><span class="line">&gt;&gt;&gt; heap = <span class="type">list</span>(nums)</span><br><span class="line">&gt;&gt;&gt; heapq.heapify(heap)</span><br><span class="line">&gt;&gt;&gt; heap</span><br><span class="line">[<span class="number">-4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">8</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>堆数据结构最重要的特征是 <code>heap[0]</code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code>heapq.heappop()</code>方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是<code>O(log N)</code> ， <code>N</code> 是堆大小）。 比如，如果想要查找最小的 <code>3</code> 个元素，你可以这样做：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; heapq.heappop(heap)</span><br><span class="line">-<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heapq.heappop(heap)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heapq.heappop(heap)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>当要查找的元素个数相对比较小的时候，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 是很合适的。 如果你仅仅想查找唯一的最小或最大（<code>N=1</code>）的元素的话，那么使用<code>min()</code> 和 <code>max()</code> 函数会更快些。 类似的，如果 <code>N</code> 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ <code>sorted(items)[:N]</code> 或者是 <code>sorted(items)[-N:]</code> ）。 需要在正确场合使用函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才能发挥它们的优势 （如果 <code>N</code> 快接近集合大小了，那么使用排序操作会更好些）。</p><p>尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且值得你深入学习的东西。 基本上只要是数据结构和算法书籍里面都会有提及到。 <code>heapq</code> 模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.05 实现一个优先级队列</title>
      <link href="/2018-06-08/1-05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2018-06-08/1-05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 <code>pop</code> 操作总是返回优先级最高的那个元素</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>下面的类利用 <code>heapq</code> 模块实现了一个简单的优先级队列：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._queue = []</span><br><span class="line">        <span class="keyword">self</span>._index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(<span class="keyword">self</span>, item, priority)</span></span><span class="symbol">:</span></span><br><span class="line">        heapq.heappush(<span class="keyword">self</span>._queue, (-priority, <span class="keyword">self</span>._index, item))</span><br><span class="line">        <span class="keyword">self</span>._index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(<span class="keyword">self</span>._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>下面是它的使用方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">self</span>.name = name</span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">return</span> <span class="string">'Item(&#123;!r&#125;)'</span>.format(<span class="keyword">self</span>.name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q = PriorityQueue()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.push(Item(<span class="string">'foo'</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.push(Item(<span class="string">'bar'</span>), <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.push(Item(<span class="string">'spam'</span>), <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.push(Item(<span class="string">'grok'</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.pop()</span><br><span class="line">Item(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.pop()</span><br><span class="line">Item(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.pop()</span><br><span class="line">Item(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; q.pop()</span><br><span class="line">Item(<span class="string">'grok'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>仔细观察可以发现，第一个 <code>pop()</code> 操作返回优先级最高的元素。另外注意到如果两个有着相同优先级的元素（ <code>foo</code> 和 <code>grok</code> ）， <code>pop</code> 操作按照它们被插入到队列的顺序返回的。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>这一小节我们主要关注 <code>heapq</code> 模块的使用。 函数<code>heapq.heappush()</code>和 <code>heapq.heappop()</code> 分别在队列 <code>_queue</code> 上插入和删除第一个元素， 并且队列 <code>_queue</code> 保证第一个元素拥有最高优先级（ <code>1.4 节</code> 已经讨论过这个问题）。 <code>heappop()</code> 函数总是返回 最小的元素，这就是保证队列 <code>pop</code> 操作返回正确元素的关键。另外，由于 <code>push</code> 和 <code>pop</code> 操作时间复杂度为 <code>O(log N)</code>，其中 <code>N</code> 是堆的大小，因此就算是 <code>N</code> 很大的时候它们运行速度也依旧很快。</p><p>在上面代码中，队列包含了一个 <code>(-priority, index, item)</code>的元组。优先级为负数的目的是使得元素按照优先级从高到低排序。这个跟普通的按优先级从低到高排序的堆排序恰巧相反。</p><p><code>index</code> 变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的 <code>index</code> 下标变量，可以确保元素按照它们插入的顺序排序。 而且， <code>index</code> 变量也在相同优先级元素比较的时候起到重要作用。</p><p>为了阐明这些，先假定 <code>Item</code> 实例是不支持排序的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = Item(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = Item(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a &lt; b</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> unorderable <span class="symbol">types:</span> Item() &lt; Item()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你使用元组 <code>(priority, item)</code> ，只要两个元素的优先级不同就能比较。 但是如果两个元素优先级一样的话，那么比较操作就会跟之前一样出错：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = (<span class="number">1</span>, Item(<span class="string">'foo'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = (<span class="number">5</span>, Item(<span class="string">'bar'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a &lt; b</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = (<span class="number">1</span>, Item(<span class="string">'grok'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a &lt; c</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> unorderable <span class="symbol">types:</span> Item() &lt; Item()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>通过引入另外的 <code>index</code> 变量组成三元组 <code>(priority, index, item)</code>，就能很好的避免上面的错误， 因为不可能有两个元素有相同的 <code>index</code> 值。 <code>Python</code> 在做元组比较时候，如果前面的比较已经可以确定结果了，后面的比较操作就不会发生了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = (<span class="number">1</span>, <span class="number">0</span>, Item(<span class="string">'foo'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = (<span class="number">5</span>, <span class="number">1</span>, Item(<span class="string">'bar'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = (<span class="number">1</span>, <span class="number">2</span>, Item(<span class="string">'grok'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a &lt; b</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a &lt; c</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想在多个线程中使用同一个队列，那么你需要增加适当的锁和信号量机制。 可以查看 <code>12.3 小节</code> 的例子演示是怎样做的。</p><p><code>heapq</code> 模块的官方文档有更详细的例子程序以及对于堆理论及其实现的详细说明。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.06 字典中的键映射多个值</title>
      <link href="/2018-06-08/1-06-%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E9%94%AE%E6%98%A0%E5%B0%84%E5%A4%9A%E4%B8%AA%E5%80%BC/"/>
      <url>/2018-06-08/1-06-%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E9%94%AE%E6%98%A0%E5%B0%84%E5%A4%9A%E4%B8%AA%E5%80%BC/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样实现一个键对应多个值的字典（也叫 <code>multidict</code> ）？<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一个字典就是一个键对应一个单值的映射。如果你想要一个键映射多个值，那么你就需要将这多个值放到另外的容器中，比如列表或者集合里面。比如，你可以像下面这样构造这样的字典：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">'a'</span> : [1, 2, 3],</span><br><span class="line">    <span class="string">'b'</span> : [4, 5]</span><br><span class="line">&#125;</span><br><span class="line">e = &#123;</span><br><span class="line">    <span class="string">'a'</span> : &#123;1, 2, 3&#125;,</span><br><span class="line">    <span class="string">'b'</span> : &#123;4, 5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择使用列表还是集合取决于你的实际需求。如果你想保持元素的插入顺序就应该使用列表，如果想去掉重复元素就使用集合（并且不关心元素的顺序问题）。</p><p>你可以很方便的使用 <code>collections</code> 模块中的 <code>defaultdict</code> 来构造这样的字典。 <code>defaultdict</code> 的一个特征是它会自动初始化每个 <code>key</code> 刚开始对应的值，所以你只需要关注添加元素操作了。比如：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(list)</span><br><span class="line">d[<span class="string">'a'</span>].<span class="built_in">append</span>(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].<span class="built_in">append</span>(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].<span class="built_in">append</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">d[<span class="string">'a'</span>].<span class="built_in">add</span>(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].<span class="built_in">add</span>(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].<span class="built_in">add</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>defaultdict</code> 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体。 如果你并不需要这样的特性，你可以在一个普通的字典上使用 <code>setdefault()</code> 方法来代替。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125; # A regular dictionary</span><br><span class="line">d.setdefault(<span class="string">'a'</span>, []).<span class="built_in">append</span>(<span class="number">1</span>)</span><br><span class="line">d.setdefault(<span class="string">'a'</span>, []).<span class="built_in">append</span>(<span class="number">2</span>)</span><br><span class="line">d.setdefault(<span class="string">'b'</span>, []).<span class="built_in">append</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>但是很多程序员觉得 <code>setdefault()</code> 用起来有点别扭。因为每次调用都得创建一个新的初始值的实例（例子程序中的空列表 <code>[]</code> ）。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>一般来讲，创建一个多值映射字典是很简单的。但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦， 你可能会像下面这样来实现：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">key</span>, value <span class="keyword">in</span> pairs:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">key</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">        d[<span class="built_in">key</span>] = []</span><br><span class="line">    d[<span class="built_in">key</span>].<span class="built_in">append</span>(value)</span><br></pre></td></tr></table></figure><p>如果使用 <code>defaultdict</code> 的话代码就更加简洁了：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">key</span>, value <span class="keyword">in</span> pairs:</span><br><span class="line">    d[<span class="built_in">key</span>].<span class="built_in">append</span>(value)</span><br></pre></td></tr></table></figure><p>这一小节所讨论的问题跟数据处理中的记录归类问题有大的关联。可以参考 <code>1.15 小节</code> 的例子。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.07 字典排序</title>
      <link href="/2018-06-08/1-07-%E5%AD%97%E5%85%B8%E6%8E%92%E5%BA%8F/"/>
      <url>/2018-06-08/1-07-%E5%AD%97%E5%85%B8%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了能控制一个字典中元素的顺序，你可以使用 <code>collections</code> 模块中的 <code>OrderedDict</code> 类。在迭代操作的时候它会保持元素被插入时的顺序，示例如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'foo'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'bar'</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">'spam'</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">'grok'</span>] = <span class="number">4</span></span><br><span class="line"># Outputs <span class="string">"foo 1"</span>, <span class="string">"bar 2"</span>, <span class="string">"spam 3"</span>, <span class="string">"grok 4"</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">key</span> in d:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">key</span>, d[<span class="built_in">key</span>])</span><br></pre></td></tr></table></figure><p>当你想要构建一个将来需要序列化或编码成其他格式的映射的时候， OrderedDict 是非常有用的。 比如，你想精确控制以 JSON 编码后字段的顺序，你可以先使用 OrderedDict 来构建这样的数据：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import json</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"foo": 1, "bar": 2, "spam": 3, "grok": 4&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>OrderedDict</code> 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候，它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。</p><p>需要注意的是，一个 <code>OrderedDict</code> 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。所以如果你要构建一个需要大量 <code>OrderedDict</code> 实例的数据结构的时候（比如读取 <code>100,000</code> 行 <code>CSV</code> 数据到一个 <code>OrderedDict</code> 列表中去）， 那么你就得仔细权衡一下是否使用 <code>OrderedDict</code> 带来的好处要大过额外内存消耗的影响。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.08 字典的运算</title>
      <link href="/2018-06-08/1-08-%E5%AD%97%E5%85%B8%E7%9A%84%E8%BF%90%E7%AE%97/"/>
      <url>/2018-06-08/1-08-%E5%AD%97%E5%85%B8%E7%9A%84%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样在数据字典中执行一些计算操作（比如求最小值、最大值、排序等等）？<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>考虑下面的股票名和价格映射字典：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">prices</span> = &#123;</span><br><span class="line">    <span class="string">'ACME'</span>: 45.23,</span><br><span class="line">    <span class="string">'AAPL'</span>: 612.78,</span><br><span class="line">    <span class="string">'IBM'</span>: 205.55,</span><br><span class="line">    <span class="string">'HPQ'</span>: 37.20,</span><br><span class="line">    <span class="string">'FB'</span>: 10.75</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对字典值执行计算操作，通常需要使用 <code>zip()</code> 函数先将键和值反转过来。 比如，下面是查找最小和最大股票价格和股票值的代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">min_price = min(<span class="name">zip</span>(<span class="name">prices</span>.values(), prices.keys()))</span><br><span class="line"># min_price is (<span class="number">10.75</span>, 'FB')</span><br><span class="line">max_price = max(<span class="name">zip</span>(<span class="name">prices</span>.values(), prices.keys()))</span><br><span class="line"># max_price is (<span class="number">612.78</span>, 'AAPL')</span><br></pre></td></tr></table></figure><p>类似的，可以使用 <code>zip()</code> 和 <code>sorted()</code> 函数来排列字典数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">prices_sorted = sorted(zip(prices.values(), prices.keys()))</span><br><span class="line"><span class="meta">#</span><span class="bash"> prices_sorted is [(10.75, <span class="string">'FB'</span>), (37.2, <span class="string">'HPQ'</span>),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                   (45.23, <span class="string">'ACME'</span>), (205.55, <span class="string">'IBM'</span>),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                   (612.78, <span class="string">'AAPL'</span>)]</span></span><br></pre></td></tr></table></figure><p>执行这些计算的时候，需要注意的是 <code>zip()</code> 函数创建的是一个只能访问一次的迭代器。比如，下面的代码就会产生错误：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prices_and_names = zip(prices.<span class="built_in">values</span>(), prices.<span class="built_in">keys</span>())</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">min</span>(prices_and_names)) # OK</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">max</span>(prices_and_names)) # ValueError: <span class="built_in">max</span>() arg <span class="keyword">is</span> <span class="keyword">an</span> <span class="built_in">empty</span> sequence</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值。比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(prices) # Returns <span class="string">'AAPL'</span></span><br><span class="line"><span class="built_in">max</span>(prices) # Returns <span class="string">'IBM'</span></span><br></pre></td></tr></table></figure><p>这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算。或许你会尝试着使用字典的 <code>values()</code> 方法来解决这个问题：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min(<span class="name">prices</span>.values()) # Returns <span class="number">10.75</span></span><br><span class="line">max(<span class="name">prices</span>.values()) # Returns <span class="number">612.78</span></span><br></pre></td></tr></table></figure><p>不幸的是，通常这个结果同样也不是你想要的。你可能还想要知道对应的键的信息（比如那种股票价格是最低的？）。</p><p>你可以在 <code>min()</code> 和 <code>max()</code> 函数中提供 <code>key</code> 函数参数来获取最小值或最大值对应的键的信息。比如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(prices, <span class="built_in">key</span>=<span class="built_in">lambda</span> k: prices[k]) # Returns 'FB'</span><br><span class="line"><span class="built_in">max</span>(prices, <span class="built_in">key</span>=<span class="built_in">lambda</span> k: prices[k]) # Returns 'AAPL'</span><br></pre></td></tr></table></figure><p>但是，如果还想要得到最小值，你又得执行一次查找操作。比如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_value = prices[<span class="built_in">min</span>(prices, <span class="built_in">key</span>=<span class="built_in">lambda</span> k: prices[k])]</span><br></pre></td></tr></table></figure><p>前面的 <code>zip()</code> 函数方案通过将字典反转为(值，键)元组序列来解决了上述问题。 当比较两个元组的时候，值会先进行比较，然后才是键。这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了。</p><p>需要注意的是在计算操作中使用到了(值，键)对。当多个实体拥有相同的值的时候，键会决定返回结果。比如，在执行 <code>min()</code> 和 <code>max()</code> 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; prices = &#123; <span class="string">'AAA'</span> : <span class="number">45.23</span>, <span class="string">'ZZZ'</span>: <span class="number">45.23</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; min(zip(prices.values(), prices.keys()))</span><br><span class="line">(<span class="number">45.23</span>, <span class="string">'AAA'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; max(zip(prices.values(), prices.keys()))</span><br><span class="line">(<span class="number">45.23</span>, <span class="string">'ZZZ'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.09 查找两字典的相同点</title>
      <link href="/2018-06-08/1-09-%E6%9F%A5%E6%89%BE%E4%B8%A4%E5%AD%97%E5%85%B8%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9/"/>
      <url>/2018-06-08/1-09-%E6%9F%A5%E6%89%BE%E4%B8%A4%E5%AD%97%E5%85%B8%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样在两个字典中寻寻找相同点（比如相同的键、相同的值等等）？<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>考虑下面两个字典：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">    <span class="string">'x'</span> : 1,</span><br><span class="line">    <span class="string">'y'</span> : 2,</span><br><span class="line">    <span class="string">'z'</span> : 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;</span><br><span class="line">    <span class="string">'w'</span> : 10,</span><br><span class="line">    <span class="string">'x'</span> : 11,</span><br><span class="line">    <span class="string">'y'</span> : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了寻找两个字典的相同点，可以简单的在两字典的 <code>keys()</code> 或者 <code>items()</code> 方法返回结果上执行集合操作。比如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Find keys <span class="keyword">in</span> common</span><br><span class="line">a.keys() &amp; b.keys() # &#123; <span class="string">'x'</span>, <span class="string">'y'</span> &#125;</span><br><span class="line"># Find keys <span class="keyword">in</span> a that are not <span class="keyword">in</span> b</span><br><span class="line">a.keys() - b.keys() # &#123; <span class="string">'z'</span> &#125;</span><br><span class="line"># Find (key,value) pairs <span class="keyword">in</span> common</span><br><span class="line">a.items() &amp; b.items() # &#123; (<span class="string">'y'</span>, <span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure><p>这些操作也可以用于修改或者过滤字典元素。比如，假如你想以现有字典构造一个排除几个指定键的新字典。下面利用字典推导来实现这样的需求：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Make a <span class="keyword">new</span> dictionary <span class="keyword">with</span> certain keys removed</span><br><span class="line">c = &#123;key:a[key] <span class="keyword">for</span> key <span class="keyword">in</span> a.keys() - &#123;<span class="string">'z'</span>, <span class="string">'w'</span>&#125;&#125;</span><br><span class="line"># c <span class="keyword">is</span> &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>一个字典就是一个键集合与值集合的映射关系。字典的 <code>keys()</code> 方法返回一个展现键集合的键视图对象。键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个 <code>set</code> 。</p><p>字典的 <code>items()</code> 方法返回一个包含 (键，值)对的元素视图对象。这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。</p><p>尽管字典的 <code>values()</code> 方法也是类似，但是它并不支持这里介绍的集合操作。 某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成 <code>set</code> ，然后再执行集合运算就行了。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.10 删除序列相同元素并保持顺序</title>
      <link href="/2018-06-08/1-10-%E5%88%A0%E9%99%A4%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E5%B9%B6%E4%BF%9D%E6%8C%81%E9%A1%BA%E5%BA%8F/"/>
      <url>/2018-06-08/1-10-%E5%88%A0%E9%99%A4%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E5%B9%B6%E4%BF%9D%E6%8C%81%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样在一个序列上面保持元素顺序的同时消除重复的值？<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果序列上的值都是 <code>hashable</code> 类型，那么可以很简单的利用集合或者生成器来解决这个问题。比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def dedupe(<span class="keyword">items</span>):</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">item</span> <span class="keyword">in</span> <span class="keyword">items</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">item</span> <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            yield <span class="keyword">item</span></span><br><span class="line">            seen.<span class="built_in">add</span>(<span class="keyword">item</span>)</span><br></pre></td></tr></table></figure><p>下面是使用上述函数的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dedupe(a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个方法仅仅在序列中元素为 <code>hashable</code> 的时候才管用。 如果你想消除元素不可哈希（比如 <code>dict</code> 类型）的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def dedupe(<span class="keyword">items</span>, key=None):</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">item</span> <span class="keyword">in</span> <span class="keyword">items</span>:</span><br><span class="line">        val = <span class="keyword">item</span> <span class="keyword">if</span> key is None <span class="keyword">else</span> key(<span class="keyword">item</span>)</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            yield <span class="keyword">item</span></span><br><span class="line">            seen.<span class="built_in">add</span>(val)</span><br></pre></td></tr></table></figure><p>这里的 <code>key</code> 参数指定了一个函数，将序列元素转换成 <code>hashable</code> 类型。下面是它的用法示例：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [ &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">2</span>, <span class="string">'y'</span>:<span class="number">4</span>&#125;]</span><br><span class="line">&gt;&gt;&gt; list(dedupe(a, key=lambda d: (d[<span class="string">'x'</span>],d[<span class="string">'y'</span>])))</span><br><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br><span class="line">&gt;&gt;&gt; list(dedupe(a, key=lambda d: d[<span class="string">'x'</span>]))</span><br><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合。比如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">&gt;&gt;&gt; set(a)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">9</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>然而，这种方法不能维护元素的顺序，生成的结果中的元素位置被打乱。而上面的方法可以避免这种情况。</p><p>在本节中我们使用了生成器函数让我们的函数更加通用，不仅仅是局限于列表处理。比如，如果如果你想读取一个文件，消除重复行，你可以很容易像这样做：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(somefile,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> dedupe(f):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上述 <code>key</code> 函数参数模仿了 <code>sorted()</code> 、 <code>min()</code> 和 <code>max()</code> 等内置函数的相似功能。可以参考 <code>1.8</code> 和 <code>1.13 小节</code>了解更多。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.01 数字的四舍五入</title>
      <link href="/2018-06-08/3-01-%E6%95%B0%E5%AD%97%E7%9A%84%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"/>
      <url>/2018-06-08/3-01-%E6%95%B0%E5%AD%97%E7%9A%84%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="第三章：数字日期和时间"><a href="#第三章：数字日期和时间" class="headerlink" title="第三章：数字日期和时间"></a>第三章：数字日期和时间</h3><p>在 Python 中执行整数和浮点数的数学运算时很简单的。尽管如此，如果你需要执行分数、数组或者是日期和时间的运算的话，就得做更多的工作了。本章集中讨论的就是这些主题。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想对浮点数执行指定精度的舍入运算。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于简单的舍入运算，使用内置的 <code>round(value, ndigits)</code> 函数即可。比如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(<span class="number">1.23</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.27</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.3</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">-1.27</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">-1.3</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.25361</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1.254</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>当一个值刚好在两个边界的中间的时候， <code>round</code> 函数返回离它最近的偶数。 也就是说，对 <code>1.5</code> 或者 <code>2.5</code> 的舍入运算都会得到 <code>2</code> 。</p><p>传给 <code>round()</code> 函数的 <code>ndigits</code> 参数可以是负数，这种情况下，舍入运算会作用在十位、百位、千位等上面。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = <span class="number">1627731</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; round(a, -<span class="number">1</span>)</span><br><span class="line"><span class="number">1627730</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; round(a, -<span class="number">2</span>)</span><br><span class="line"><span class="number">1627700</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; round(a, -<span class="number">3</span>)</span><br><span class="line"><span class="number">1628000</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>不要将舍入和格式化输出搞混淆了。如果你的目的只是简单的输出一定宽度的数，你不需要使用 <code>round()</code> 函数。 而仅仅只需要在格式化的时候指定精度即可。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = <span class="number">1.23456</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'0.2f'</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'0.3f'</span>)</span><br><span class="line"><span class="string">'1.235'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'value is &#123;:0.3f&#125;'</span>.format(x)</span><br><span class="line"><span class="string">'value is 1.235'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>同样，不要试着去舍入浮点值来 <code>修正</code> 表面上看起来正确的问题。比如，你可能倾向于这样做：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = <span class="number">2.1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = <span class="number">4.2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = a + b</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c</span><br><span class="line"><span class="number">6.300000000000001</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = round(c, <span class="number">2</span>) <span class="comment"># "Fix" result (???)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c</span><br><span class="line"><span class="number">6.3</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>对于大多数使用到浮点的程序，没有必要也不推荐这样做。尽管在计算的时候会有一点点小的误差，但是这些小的误差是能被理解与容忍的。 如果不能允许这样的小误差 ( 比如涉及到金融领域 ) ，那么就得考虑使用 <code>decimal</code> 模块了，下一节我们会详细讨论。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.02 执行精确的浮点数运算</title>
      <link href="/2018-06-08/3-02-%E6%89%A7%E8%A1%8C%E7%B2%BE%E7%A1%AE%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2018-06-08/3-02-%E6%89%A7%E8%A1%8C%E7%B2%BE%E7%A1%AE%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要对浮点数执行精确的计算操作，并且不希望有任何小误差的出现。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>浮点数的一个普遍问题是它们并不能精确的表示十进制数。并且，即使是最简单的数学运算也会产生小的误差，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = <span class="number">4.2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = <span class="number">2.1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a + b</span><br><span class="line"><span class="number">6.300000000000001</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; (a + b) == <span class="number">6.3</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>这些错误是由底层 <code>CPU</code> 和 <code>IEEE 754</code> 标准通过自己的浮点单位去执行算术时的特征。由于 <code>Python</code> 的浮点数据类型使用底层表示存储数据，因此你没办法去避免这样的误差。</p><p>如果你想更加精确(并能容忍一定的性能损耗)，你可以使用 <code>decimal</code> 模块：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from decimal import Decimal</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = Decimal(<span class="string">'4.2'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> = Decimal(<span class="string">'2.1'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> + b</span><br><span class="line"><span class="function"><span class="title">Decimal</span><span class="params">(<span class="string">'6.3'</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; print(<span class="selector-tag">a</span> + b)</span><br><span class="line"><span class="number">6.3</span></span><br><span class="line">&gt;&gt;&gt; (<span class="selector-tag">a</span> + b) == Decimal(<span class="string">'6.3'</span>)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>初看起来，上面的代码好像有点奇怪，比如我们用字符串来表示数字。然而， <code>Decimal</code> 对象会像普通浮点数一样的工作(支持所有的常用数学运算)。如果你打印它们或者在字符串格式化函数中使用它们，看起来跟普通数字没什么两样。</p><p><code>decimal</code> 模块的一个主要特征是允许你控制计算的每一方面，包括数字位数和四舍五入运算。 为了这样做，你先得创建一个本地上下文并更改它的设置，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> localcontext</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Decimal(<span class="string">'1.3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Decimal(<span class="string">'1.7'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a / b)</span><br><span class="line"><span class="number">0.7647058823529411764705882353</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> localcontext() <span class="keyword">as</span> ctx:</span><br><span class="line"><span class="meta">... </span>    ctx.prec = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    print(a / b)</span><br><span class="line">...</span><br><span class="line"><span class="number">0.765</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> localcontext() <span class="keyword">as</span> ctx:</span><br><span class="line"><span class="meta">... </span>    ctx.prec = <span class="number">50</span></span><br><span class="line"><span class="meta">... </span>    print(a / b)</span><br><span class="line">...</span><br><span class="line"><span class="number">0.76470588235294117647058823529411764705882352941176</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>decimal</code> 模块实现了 <code>IBM</code> 的 通用小数运算规范。不用说，有很多的配置选项这本书没有提到。</p><p><code>Python</code> 新手会倾向于使用 <code>decimal</code> 模块来处理浮点数的精确运算。然而，先理解你的应用程序目的是非常重要的。如果你是在做科学计算或工程领域的计算、电脑绘图，或者是科学领域的大多数运算，那么使用普通的浮点类型是比较普遍的做法。其中一个原因是，在真实世界中很少会要求精确到普通浮点数能提供的 <code>17</code> 位精度。因此，计算过程中的那么一点点的误差是被允许的。第二点就是，原生的浮点数计算要快的多-有时候你在执行大量运算的时候速度也是非常重要的。</p><p>即便如此，你却不能完全忽略误差。数学家花了大量时间去研究各类算法，有些处理误差会比其他方法更好。你也得注意下减法删除以及大数和小数的加分运算所带来的影响。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; nums = [<span class="number">1.23</span>e+<span class="number">18</span>, <span class="number">1</span>, -<span class="number">1.23</span>e+<span class="number">18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sum(nums) <span class="comment"># Notice how 1 disappears</span></span><br><span class="line"><span class="number">0</span>.<span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的错误可以利用<code>math.fsum()</code>所提供的更精确计算能力来解决：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import math</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; math.fsum(nums)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>然而，对于其他的算法，你应该仔细研究它并理解它的误差产生来源。</p><p>总的来说， <code>decimal</code> 模块主要用在涉及到金融的领域。在这类程序中，哪怕是一点小小的误差在计算过程中蔓延都是不允许的。 因此，<code>decimal</code> 模块为解决这类问题提供了方法。当 <code>Python</code> 和数据库打交道的时候也通常会遇到 <code>Decimal</code> 对象，并且，通常也是在处理金融数据的时候。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.03 数字的格式化输出</title>
      <link href="/2018-06-08/3-03-%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"/>
      <url>/2018-06-08/3-03-%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要将数字格式化后输出，并控制数字的位数、对齐、千位分隔符和其他的细节。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>格式化输出单个数字的时候，可以使用内置的 <code>format()</code> 函数，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = <span class="number">1234.56789</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Two decimal places of accuracy</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'0.2f'</span>)</span><br><span class="line"><span class="string">'1234.57'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Right justified in 10 chars, one-digit accuracy</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'&gt;10.1f'</span>)</span><br><span class="line"><span class="string">'    1234.6'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Left justified</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'&lt;10.1f'</span>)</span><br><span class="line"><span class="string">'1234.6    '</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Centered</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'^10.1f'</span>)</span><br><span class="line"><span class="string">'  1234.6  '</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Inclusion of thousands separator</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">','</span>)</span><br><span class="line"><span class="string">'1,234.56789'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'0,.1f'</span>)</span><br><span class="line"><span class="string">'1,234.6'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想使用指数记法，将 <code>f</code> 改成 <code>e</code> 或者 <code>E</code> (取决于指数输出的大小写形式)。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'e'</span>)</span><br><span class="line"><span class="string">'1.234568e+03'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'0.2E'</span>)</span><br><span class="line"><span class="string">'1.23E+03'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>同时指定宽度和精度的一般形式是 <code>[&lt;&gt;^]?width[,]?(.digits)?</code> ， 其中 <code>width</code> 和 <code>digits</code> 为整数，<code>？</code> 代表可选部分。 同样的格式也被用在字符串的 <code>format()</code> 方法中。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'The value is &#123;:0,.2f&#125;'</span>.format(x)</span><br><span class="line"><span class="string">'The value is 1,234.57'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>数字格式化输出通常是比较简单的。上面演示的技术同时适用于浮点数和 <code>decimal</code> 模块中的 <code>Decimal</code> 数字对象。</p><p>当指定数字的位数后，结果值会根据 <code>round()</code> 函数同样的规则进行四舍五入后返回。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x</span><br><span class="line"><span class="number">1234.56789</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'0.1f'</span>)</span><br><span class="line"><span class="string">'1234.6'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(-x, <span class="string">'0.1f'</span>)</span><br><span class="line"><span class="string">'-1234.6'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>包含千位符的格式化跟本地化没有关系。如果你需要根据地区来显示千位符，你需要自己去调查下 <code>locale</code> 模块中的函数了。 你同样也可以使用字符串的 <code>translate()</code> 方法来交换千位符。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; swap_separators = &#123; ord(<span class="string">'.'</span>)<span class="symbol">:<span class="string">','</span></span>, ord(<span class="string">','</span>)<span class="symbol">:<span class="string">'.'</span></span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">','</span>).translate(swap_separators)</span><br><span class="line"><span class="string">'1.234,56789'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line">在很多 Python 代码中会看到使用%来格式化数字的，比如：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'%0.2f'</span> % x</span><br><span class="line"><span class="string">'1234.57'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'%10.1f'</span> % x</span><br><span class="line"><span class="string">'    1234.6'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'%-10.1f'</span> % x</span><br><span class="line"><span class="string">'1234.6    '</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>这种格式化方法也是可行的，不过比更加先进的 <code>format()</code> 要差一点。比如，在使用 <code>%</code> 操作符格式化数字的时候，一些特性(添加千位符)并不能被支持。</p><p>更多详细内容参考：</p><ul><li><a href="http://codebooks.dongfei.xin/2018-06-07/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95-format-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/">Python 字符串格式化方法 format 函数的使用</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.04 二、八、十六进制整数</title>
      <link href="/2018-06-08/3-04-%E4%BA%8C%E3%80%81%E5%85%AB%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0/"/>
      <url>/2018-06-08/3-04-%E4%BA%8C%E3%80%81%E5%85%AB%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要转换或者输出使用二进制，八进制或十六进制表示的整数。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了将整数转换为二进制、八进制或十六进制的文本串， 可以分别使用 <code>bin()</code> , <code>oct()</code> 或 <code>hex()</code> 函数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; bin(x)</span><br><span class="line"><span class="string">'0b10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; oct(x)</span><br><span class="line"><span class="string">'0o2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; hex(x)</span><br><span class="line"><span class="string">'0x4d2'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>另外，如果你不想输出 <code>0b</code> , <code>0o</code> 或者 <code>0x</code> 的前缀的话，可以使用 <code>format()</code> 函数。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'o'</span>)</span><br><span class="line"><span class="string">'2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'x'</span>)</span><br><span class="line"><span class="string">'4d2'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>整数是有符号的，所以如果你在处理负数的话，输出结果会包含一个负号。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = -<span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'-10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(x, <span class="string">'x'</span>)</span><br><span class="line"><span class="string">'-4d2'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想产生一个无符号值，你需要增加一个指示最大位长度的值。比如为了显示 <code>32</code> 位的值，可以像下面这样写：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = -<span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(<span class="number">2</span>**<span class="number">32</span> + x, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'11111111111111111111101100101110'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; format(<span class="number">2</span>**<span class="number">32</span> + x, <span class="string">'x'</span>)</span><br><span class="line"><span class="string">'fffffb2e'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>为了以不同的进制转换整数字符串，简单的使用带有进制的int()函数即可：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'4d2'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'10011010010'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>大多数情况下处理二进制、八进制和十六进制整数是很简单的。只要记住这些转换属于整数和其对应的文本表示之间的转换即可。永远只有一种整数类型。</p><p>最后，使用八进制的程序员有一点需要注意下。 <code>Python</code> 指定八进制数的语法跟其他语言稍有不同。比如，如果你像下面这样指定八进制，会出现语法错误：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import os</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; os.chmod(<span class="string">'script.py'</span>, <span class="number">0755</span>)</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">        os.chmod(<span class="string">'script.py'</span>, <span class="number">0755</span>)</span><br><span class="line">                            ^</span><br><span class="line"><span class="symbol">SyntaxError:</span> invalid token</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>需确保八进制数的前缀是 <code>0o</code> ，就像下面这样：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; os.chmod(<span class="string">'script.py'</span>, 0o755)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.05 字节到大整数的打包与解包</title>
      <link href="/2018-06-08/3-05-%E5%AD%97%E8%8A%82%E5%88%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E8%A7%A3%E5%8C%85/"/>
      <url>/2018-06-08/3-05-%E5%AD%97%E8%8A%82%E5%88%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E8%A7%A3%E5%8C%85/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.06 复数的数学运算</title>
      <link href="/2018-06-08/3-06-%E5%A4%8D%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97/"/>
      <url>/2018-06-08/3-06-%E5%A4%8D%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你写的最新的网络认证方案代码遇到了一个难题，并且你唯一的解决办法就是使用复数空间。再或者是你仅仅需要使用复数来执行一些计算操作。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>复数可以用使用函数<code>complex(real, imag)</code>或者是带有后缀<code>j</code>的浮点数来指定。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = complex(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = <span class="number">3</span> - <span class="number">5</span>j</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line">(<span class="number">2</span>+<span class="number">4</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b</span><br><span class="line">(<span class="number">3</span>-<span class="number">5</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>对应的实部、虚部和共轭复数可以很容易的获取。就像下面这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.real</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.imag</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.conjugate()</span><br><span class="line">(<span class="number">2</span>-<span class="number">4</span>j)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>另外，所有常见的数学运算都可以工作：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a + b</span><br><span class="line">(<span class="number">5</span>-<span class="number">1</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a * b</span><br><span class="line">(<span class="number">26</span>+<span class="number">2</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a / b</span><br><span class="line">(-<span class="number">0</span>.<span class="number">4117647058823529</span>+<span class="number">0</span>.<span class="number">6470588235294118</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; abs(a)</span><br><span class="line"><span class="number">4.47213595499958</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果要执行其他的复数函数比如正弦、余弦或平方根，使用 <code>cmath</code> 模块：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import cmath</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; cmath.sin(a)</span><br><span class="line">(<span class="number">24.83130584894638</span>-<span class="number">11.356612711218174</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; cmath.cos(a)</span><br><span class="line">(-<span class="number">11.36423470640106</span>-<span class="number">24.814651485634187</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; cmath.exp(a)</span><br><span class="line">(-<span class="number">4.829809383269385</span>-<span class="number">5.5920560936409816</span>j)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>Python</code> 中大部分与数学相关的模块都能处理复数。比如如果你使用 <code>numpy</code> ，可以很容易的构造一个复数数组并在这个数组上执行各种操作：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; a = np.array([<span class="number">2</span>+<span class="number">3</span>j, <span class="number">4</span>+<span class="number">5</span>j, <span class="number">6</span><span class="number">-7</span>j, <span class="number">8</span>+<span class="number">9</span>j])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([ <span class="number">2.</span>+<span class="number">3.</span>j, <span class="number">4.</span>+<span class="number">5.</span>j, <span class="number">6.</span><span class="number">-7.</span>j, <span class="number">8.</span>+<span class="number">9.</span>j])</span><br><span class="line">&gt;&gt;&gt; a + <span class="number">2</span></span><br><span class="line">array([ <span class="number">4.</span>+<span class="number">3.</span>j, <span class="number">6.</span>+<span class="number">5.</span>j, <span class="number">8.</span><span class="number">-7.</span>j, <span class="number">10.</span>+<span class="number">9.</span>j])</span><br><span class="line">&gt;&gt;&gt; np.sin(a)</span><br><span class="line">array([ <span class="number">9.15449915</span> <span class="number">-4.16890696</span>j, <span class="number">-56.16227422</span> <span class="number">-48.50245524</span>j,</span><br><span class="line">        <span class="number">-153.20827755</span><span class="number">-526.47684926</span>j, <span class="number">4008.42651446</span><span class="number">-589.49948373</span>j])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>Python</code> 的标准数学函数确实情况下并不能产生复数值，因此你的代码中不可能会出现复数返回值。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import math</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; math.sqrt(-<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">ValueError:</span> math domain error</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想生成一个复数返回结果，你必须显示的使用 <code>cmath</code> 模块，或者在某个支持复数的库中声明复数类型的使用。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import cmath</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; cmath.sqrt(-<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span>j</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.07 无穷大与 NaN</title>
      <link href="/2018-06-08/3-07-%E6%97%A0%E7%A9%B7%E5%A4%A7%E4%B8%8E-NaN/"/>
      <url>/2018-06-08/3-07-%E6%97%A0%E7%A9%B7%E5%A4%A7%E4%B8%8E-NaN/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想创建或测试正无穷、负无穷或 <code>NaN</code> (非数字)的浮点数。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>Python</code> 并没有特殊的语法来表示这些特殊的浮点值，但是可以使用 <code>float()</code> 来创建它们。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="built_in">float</span>(<span class="string">'-inf'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = <span class="built_in">float</span>(<span class="string">'nan'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b</span></span><br><span class="line">-inf</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>为了测试这些值的存在，使用 <code>math.isinf()</code> 和 <code>math.isnan()</code> 函数。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; math.isinf(a)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; math.isnan(c)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>想了解更多这些特殊浮点值的信息，可以参考 <code>IEEE 754 规范</code>。 然而，也有一些地方需要你特别注意，特别是跟比较和操作符相关的时候。</p><p>无穷大数在执行数学计算的时候会传播，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a + 45</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a * 10</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 10 / a</span></span><br><span class="line">0.0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>但是有些操作时未定义的并会返回一个 <code>NaN</code> 结果。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a/a</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="built_in">float</span>(<span class="string">'-inf'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a + b</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 值会在所有操作中传播，而不会产生异常。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = <span class="built_in">float</span>(<span class="string">'nan'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c + 23</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c / 2</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c * 2</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; math.sqrt(c)</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 值的一个特别的地方时它们之间的比较操作总是返回 <code>False</code> 。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = <span class="built_in">float</span>(<span class="string">'nan'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; d = <span class="built_in">float</span>(<span class="string">'nan'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c == d</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c is d</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>由于这个原因，测试一个 <code>NaN</code> 值得唯一安全的方法就是使用 <code>math.isnan()</code>，也就是上面演示的那样。</p><p>有时候程序员想改变 <code>Python</code> 默认行为，在返回无穷大或 <code>NaN</code> 结果的操作中抛出异常。 <code>fpectl</code> 模块可以用来改变这种行为，但是它在标准的 <code>Python</code> 构建中并没有被启用，它是平台相关的，并且针对的是专家级程序员。可以参考在线的 <code>Python文档</code> 获取更多的细节。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.08 分数运算</title>
      <link href="/2018-06-08/3-08-%E5%88%86%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2018-06-08/3-08-%E5%88%86%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你进入时间机器，突然发现你正在做小学家庭作业，并涉及到分数计算问题。或者你可能需要写代码去计算在你的木工工厂中的测量值。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>fractions</code> 模块可以被用来执行包含分数的数学运算。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from fractions import Fraction</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = Fraction(5, 4)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = Fraction(7, 16)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(a + b)</span></span><br><span class="line">27/16</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(a * b)</span></span><br><span class="line">35/64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Getting numerator/denominator</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = a * b</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c.numerator</span></span><br><span class="line">35</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c.denominator</span></span><br><span class="line">64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Converting to a float</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">float</span>(c)</span></span><br><span class="line">0.546875</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Limiting the denominator of a value</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(c.limit_denominator(8))</span></span><br><span class="line">4/7</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Converting a float to a fraction</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; x = 3.75</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; y = Fraction(*x.as_integer_ratio())</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; y</span></span><br><span class="line">Fraction(15, 4)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>在大多数程序中一般不会出现分数的计算问题，但是有时候还是需要用到的。比如，在一个允许接受分数形式的测试单位并以分数形式执行运算的程序中，直接使用分数可以减少手动转换为小数或浮点数的工作。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.09 大型数组运算</title>
      <link href="/2018-06-08/3-09-%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/"/>
      <url>/2018-06-08/3-09-%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要在大数据集(比如数组或网格)上面执行计算。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>涉及到数组的重量级运算操作，可以使用 <code>NumPy</code> 库。<code>NumPy</code> 的一个主要特征是它会给 <code>Python</code> 提供一个数组对象，相比标准的 <code>Python</code> 列表而已更适合用来做数学运算。下面是一个简单的小例子，向你展示标准列表对象和 <code>NumPy</code> 数组对象之间的差别：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Python lists</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; y = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x + <span class="number">10</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> can only concatenate list (<span class="keyword">not</span> <span class="string">"int"</span>) to list</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x + y</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Numpy arrays</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; import numpy as np</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; ax = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; ay = np.array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; ax * <span class="number">2</span></span><br><span class="line">array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; ax + <span class="number">10</span></span><br><span class="line">array([<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; ax + ay</span><br><span class="line">array([ <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; ax * ay</span><br><span class="line">array([ <span class="number">5</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">32</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>正如所见，两种方案中数组的基本数学运算结果并不相同。特别的， <code>NumPy</code> 中的标量运算(比如 <code>ax * 2</code> 或 <code>ax + 10</code> )会作用在每一个元素上。另外，当两个操作数都是数组的时候执行元素对等位置计算，并最终生成一个新的数组。</p><p>对整个数组中所有元素同时执行数学运算可以使得作用在整个数组上的函数运算简单而又快速。比如，如果你想计算多项式的值，可以这样做：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">... <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span> - <span class="number">2</span>*x + <span class="number">7</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f(ax)</span><br><span class="line">array([ <span class="number">8</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">47</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p><code>NumPy</code> 还为数组操作提供了大量的通用函数，这些函数可以作为 <code>math</code> 模块中类似函数的替代。比如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.sqrt(ax)</span><br><span class="line">array([ <span class="number">1.</span> , <span class="number">1.41421356</span>, <span class="number">1.73205081</span>, <span class="number">2.</span> ])</span><br><span class="line">&gt;&gt;&gt; np.cos(ax)</span><br><span class="line">array([ <span class="number">0.54030231</span>, <span class="number">-0.41614684</span>, <span class="number">-0.9899925</span> , <span class="number">-0.65364362</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>使用这些通用函数要比循环数组并使用 <code>math</code> 模块中的函数执行计算要快的多。因此，只要有可能的话尽量选择 <code>NumPy</code> 的数组方案。</p><p>底层实现中， <code>NumPy</code> 数组使用了 <code>C</code> 或者 <code>Fortran</code> 语言的机制分配内存。也就是说，它们是一个非常大的连续的并由同类型数据组成的内存区域。所以，你可以构造一个比普通 <code>Python</code> 列表大的多的数组。比如，如果你想构造一个<code>10,000*10,000</code> 的浮点数二维网格，很轻松：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; grid = np.zeros(shape=(<span class="number">10000</span>,<span class="number">10000</span>), dtype=<span class="type">float</span>)</span><br><span class="line">&gt;&gt;&gt; grid</span><br><span class="line">    array([[ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    ...,</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>所有的普通操作还是会同时作用在所有元素上：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; grid += <span class="number">10</span></span><br><span class="line">&gt;&gt;&gt; grid</span><br><span class="line">array([[ <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>, ..., <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>],</span><br><span class="line">    [ <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>, ..., <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>],</span><br><span class="line">    [ <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>, ..., <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>],</span><br><span class="line">    ...,</span><br><span class="line">    [ <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>, ..., <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>],</span><br><span class="line">    [ <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>, ..., <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>],</span><br><span class="line">    [ <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>, ..., <span class="number">10.</span>, <span class="number">10.</span>, <span class="number">10.</span>]])</span><br><span class="line">&gt;&gt;&gt; np.sin(grid)</span><br><span class="line">array([[<span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, ..., <span class="number">-0.54402111</span>,</span><br><span class="line">        <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>],</span><br><span class="line">    [<span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, ..., <span class="number">-0.54402111</span>,</span><br><span class="line">        <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>],</span><br><span class="line">    [<span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, ..., <span class="number">-0.54402111</span>,</span><br><span class="line">        <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>],</span><br><span class="line">    ...,</span><br><span class="line">    [<span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, ..., <span class="number">-0.54402111</span>,</span><br><span class="line">        <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>],</span><br><span class="line">    [<span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, ..., <span class="number">-0.54402111</span>,</span><br><span class="line">        <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>],</span><br><span class="line">    [<span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>, ..., <span class="number">-0.54402111</span>,</span><br><span class="line">        <span class="number">-0.54402111</span>, <span class="number">-0.54402111</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>关于 <code>NumPy</code> 有一点需要特别的主意，那就是它扩展 <code>Python</code> 列表的索引功能 - 特别是对于多维数组。为了说明清楚，先构造一个简单的二维数组并试着做些试验：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">[ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">[ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Select row 1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a[<span class="number">1</span>]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Select column 1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a[<span class="symbol">:</span>,<span class="number">1</span>]</span><br><span class="line">array([ <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Select a subregion and change it</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a[<span class="number">1</span><span class="symbol">:</span><span class="number">3</span>, <span class="number">1</span><span class="symbol">:</span><span class="number">3</span>]</span><br><span class="line">array([[ <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a[<span class="number">1</span><span class="symbol">:</span><span class="number">3</span>, <span class="number">1</span><span class="symbol">:</span><span class="number">3</span>] += <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Broadcast a row vector across an operation on all rows</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a + [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>]</span><br><span class="line">array([[<span class="number">101</span>, <span class="number">103</span>, <span class="number">105</span>, <span class="number">107</span>],</span><br><span class="line">        [<span class="number">105</span>, <span class="number">117</span>, <span class="number">119</span>, <span class="number">111</span>],</span><br><span class="line">        [<span class="number">109</span>, <span class="number">121</span>, <span class="number">123</span>, <span class="number">115</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Conditional assignment on an array</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; np.where(a &lt; <span class="number">10</span>, a, <span class="number">10</span>)</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>NumPy</code> 是 <code>Python</code> 领域中很多科学与工程库的基础，同时也是被广泛使用的最大最复杂的模块。即便如此，在刚开始的时候通过一些简单的例子和玩具程序也能帮我们完成一些有趣的事情。</p><p>通常我们导入 <code>NumPy</code> 模块的时候会使用语句 <code>import numpy as np</code> 。这样的话你就不用再你的程序里面一遍遍的敲入 <code>numpy</code> ，只需要输入 <code>np</code> 就行了，节省了不少时间。</p><p>如果想获取更多的信息，你当然得去 <code>NumPy</code> 官网逛逛了，网址是： <a href="http://www.numpy.org" target="_blank" rel="noopener">http://www.numpy.org</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.10 矩阵与线性代数运算</title>
      <link href="/2018-06-08/3-10-%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2018-06-08/3-10-%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要执行矩阵和线性代数运算，比如矩阵乘法、寻找行列式、求解线性方程组等等。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>NumPy</code> 库有一个矩阵对象可以用来解决这个问题。矩阵类似于 <code>3.9 小节</code> 中数组对象，但是遵循线性代数的计算规则。下面的一个例子展示了矩阵的一些基本特性：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; m = np.matrix([[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">-9</span>]])</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">matrix([[ <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">-9</span>]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # Return transpose</span><br><span class="line">&gt;&gt;&gt; m.T</span><br><span class="line">matrix([[ <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">-2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">3</span>, <span class="number">5</span>, <span class="number">-9</span>]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # Return inverse</span><br><span class="line">&gt;&gt;&gt; m.I</span><br><span class="line">matrix([[ <span class="number">0.33043478</span>, <span class="number">-0.02608696</span>, <span class="number">0.09565217</span>],</span><br><span class="line">        [<span class="number">-0.15217391</span>, <span class="number">0.13043478</span>, <span class="number">0.02173913</span>],</span><br><span class="line">        [ <span class="number">0.12173913</span>, <span class="number">0.09565217</span>, <span class="number">-0.0173913</span> ]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # Create a <span class="type">vector</span> and multiply</span><br><span class="line">&gt;&gt;&gt; v = np.matrix([[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]])</span><br><span class="line">&gt;&gt;&gt; v</span><br><span class="line">matrix([[<span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>]])</span><br><span class="line">&gt;&gt;&gt; m * v</span><br><span class="line">matrix([[ <span class="number">8</span>],</span><br><span class="line">        [<span class="number">32</span>],</span><br><span class="line">        [ <span class="number">2</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>可以在 <code>numpy.linalg</code> 子包中找到更多的操作函数，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import numpy.linalg</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Determinant</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; numpy.linalg.det(m)</span><br><span class="line">-<span class="number">229.99999999999983</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Eigenvalues</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; numpy.linalg.eigvals(m)</span><br><span class="line">array([-<span class="number">13.11474312</span>, <span class="number">2.75956154</span>, <span class="number">6.35518158</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Solve for x in mx = v</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = numpy.linalg.solve(m, v)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x</span><br><span class="line">matrix([[ <span class="number">0</span>.<span class="number">96521739</span>],</span><br><span class="line">        [ <span class="number">0</span>.<span class="number">17391304</span>],</span><br><span class="line">        [ <span class="number">0</span>.<span class="number">46086957</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m * x</span><br><span class="line">matrix([[ <span class="number">2</span>.],</span><br><span class="line">        [ <span class="number">3</span>.],</span><br><span class="line">        [ <span class="number">4</span>.]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; v</span><br><span class="line">matrix([[<span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>很显然线性代数是个非常大的主题，已经超出了本书能讨论的范围。但是，如果你需要操作数组和向量的话，<code>NumPy</code> 是一个不错的入口点。可以访问 <code>NumPy</code> 官网 <a href="http://www.numpy.org" target="_blank" rel="noopener">http://www.numpy.org</a> 获取更多信息。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 数字日期和时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.01 使用多个界定符分割字符串</title>
      <link href="/2018-06-08/2-01-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%95%8C%E5%AE%9A%E7%AC%A6%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018-06-08/2-01-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%95%8C%E5%AE%9A%E7%AC%A6%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="第二章：字符串和文本"><a href="#第二章：字符串和文本" class="headerlink" title="第二章：字符串和文本"></a>第二章：字符串和文本</h3><p>几乎所有有用的程序都会涉及到某些文本处理，不管是解析数据还是产生输出。这一章将重点关注文本的操作处理，比如提取字符串，搜索，替换以及解析等。大部分的问题都能简单的调用字符串的内建方法完成。但是，一些更为复杂的操作可能需要正则表达式或者强大的解析器，所有这些主题我们都会详细讲解。并且在操作 <code>Unicode</code> 时候碰到的一些棘手的问题在这里也会被提及到。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要将一个字符串分割为多个字段，但是分隔符（还有周围的空格）并不是固定的。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>string</code> 对象的 <code>split()</code> 方法只适应于非常简单的字符串分割情形， 它并不允许有多个分隔符或者是分隔符周围不确定的空格。当你需要更加灵活的切割字符串的时候，最好使用 <code>re.split()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line = <span class="string">'asdf fjdk; afed, fjek,asdf, foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[;,\s]\s*'</span>, line)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>函数<code>re.split()</code>是非常实用的，因为它允许你为分隔符指定多个正则模式。比如，在上面的例子中，分隔符可以是 逗号，分号或者是 空格，并且后面紧跟着任意个的空格。只要这个模式被找到，那么匹配的分隔符两边的实体都会被当成是结果中的元素返回。 返回结果为一个字段列表，这个跟 <code>str.split()</code> 返回值类型是一样的。</p><p>当你使用 <code>re.split()</code> 函数时候，需要特别注意的是正则表达式中是否包含一个括号捕获分组。如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。比如，观察一下这段代码运行后的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fields = re.split(<span class="string">r'(;|,|\s)\s*'</span>, line)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fields</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">' '</span>, <span class="string">'fjdk'</span>, <span class="string">';'</span>, <span class="string">'afed'</span>, <span class="string">','</span>, <span class="string">'fjek'</span>, <span class="string">','</span>, <span class="string">'asdf'</span>, <span class="string">','</span>, <span class="string">'foo'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>获取分割字符在某些情况下也是有用的。比如，你可能想保留分割字符串，用来在后面重新构造一个新的输出字符串：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; values = fields[<span class="symbol">:</span><span class="symbol">:</span><span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; delimiters = fields[<span class="number">1</span><span class="symbol">:</span><span class="symbol">:</span><span class="number">2</span>] + [<span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; values</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; delimiters</span><br><span class="line">[<span class="string">' '</span>, <span class="string">';'</span>, <span class="string">','</span>, <span class="string">','</span>, <span class="string">','</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Reform the line using the same delimiters</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">''</span>.join(v+d for v,d in zip(values, delimiters))</span><br><span class="line"><span class="string">'asdf fjdk;afed,fjek,asdf,foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话，确保你的分组是非捕获分组，形如 <code>(?:...)</code> 。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(?:,|;|\s)\s*'</span>, line)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.02 字符串开头或结尾匹配</title>
      <link href="/2018-06-08/2-02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%80%E5%A4%B4%E6%88%96%E7%BB%93%E5%B0%BE%E5%8C%B9%E9%85%8D/"/>
      <url>/2018-06-08/2-02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%80%E5%A4%B4%E6%88%96%E7%BB%93%E5%B0%BE%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要通过指定的文本模式去检查字符串的开头或者结尾，比如文件名后缀 、<code>URL</code>、 <code>Scheme</code> 等等。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>检查字符串开头或结尾的一个简单方法是使用 <code>str.startswith()</code> 或者是 <code>str.endswith()</code> 方法。比如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; filename = <span class="string">'spam.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filename.endswith(<span class="string">'.txt'</span>)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filename.startswith(<span class="string">'file:'</span>)</span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url = <span class="string">'http://www.python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url.startswith(<span class="string">'http:'</span>)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><p>如果你想检查多种匹配可能，只需要将所有的匹配项放入到一个元组中去，然后传给 <code>startswith()</code> 或者 <code>endswith()</code> 方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import os</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filenames = os.listdir(<span class="string">'.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filenames</span><br><span class="line">[ <span class="string">'Makefile'</span>, <span class="string">'foo.c'</span>, <span class="string">'bar.py'</span>, <span class="string">'spam.c'</span>, <span class="string">'spam.h'</span> ]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; [name for name in filenames if name.endswith((<span class="string">'.c'</span>, <span class="string">'.h'</span>)) ]</span><br><span class="line">[<span class="string">'foo.c'</span>, <span class="string">'spam.c'</span>, <span class="string">'spam.h'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; any(name.endswith(<span class="string">'.py'</span>) for name in filenames)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>下面是另一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> name.startswith((<span class="string">'http:'</span>, <span class="string">'https:'</span>, <span class="string">'ftp:'</span>)):</span><br><span class="line">        <span class="keyword">return</span> urlopen(name).read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(name) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure><p>奇怪的是，这个方法中必须要输入一个元组作为参数。 如果你恰巧有一个 <code>list</code> 或者 <code>set</code> 类型的选择项，要确保传递参数前先调用 <code>tuple()</code> 将其转换为元组类型。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; choices = [<span class="string">'http:'</span>, <span class="string">'ftp:'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url = <span class="string">'http://www.python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url.startswith(choices)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> startswith first arg must be str <span class="keyword">or</span> a tuple of str, <span class="keyword">not</span> list</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url.startswith(tuple(choices))</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>startswith()</code>和 <code>endswith()</code> 方法提供了一个非常方便的方式去做字符串开头和结尾的检查。类似的操作也可以使用切片来实现，但是代码看起来没有那么优雅。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; filename = <span class="string">'spam.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filename[-<span class="number">4</span><span class="symbol">:</span>] == <span class="string">'.txt'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url = <span class="string">'http://www.python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url[<span class="symbol">:</span><span class="number">5</span>] == <span class="string">'http:'</span> or url[<span class="symbol">:</span><span class="number">6</span>] == <span class="string">'https:'</span> or url[<span class="symbol">:</span><span class="number">4</span>] == <span class="string">'ftp:'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>你可以能还想使用正则表达式去实现，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import re</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; url = <span class="string">'http://www.python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.match(<span class="string">'http:|https:|ftp:'</span>, url)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x101253098</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>这种方式也行得通，但是对于简单的匹配实在是有点小材大用了，本节中的方法更加简单并且运行会更快些。</p><p>最后提一下，当和其他操作比如普通数据聚合相结合的时候 <code>startswith()</code> 和 <code>endswith()</code> 方法是很不错的。比如，下面这个语句检查某个文件夹中是否存在指定的文件类型：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> any(<span class="keyword">name</span>.endswith((<span class="string">'.c'</span>, <span class="string">'.h'</span>)) <span class="keyword">for</span> <span class="keyword">name</span> <span class="keyword">in</span> listdir(dirname)):</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.03 用 Shell 通配符匹配字符串</title>
      <link href="/2018-06-08/2-03-%E7%94%A8-Shell-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018-06-08/2-03-%E7%94%A8-Shell-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想使用 <code>Unix Shell</code> 中常用的通配符(比如 <code>*.py 、Dat[0-9]*.csv</code> 等)去匹配文本字符串</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>fnmatch</code> 模块提供了两个函数 —— <code>fnmatch()</code> 和 <code>fnmatchcase()</code> ，可以用来实现这样的匹配。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from fnmatch import fnmatch, fnmatchcase</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.txt'</span>)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'?oo.txt'</span>)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; fnmatch(<span class="string">'Dat45.csv'</span>, <span class="string">'Dat[0-9]*'</span>)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; names = [<span class="string">'Dat1.csv'</span>, <span class="string">'Dat2.csv'</span>, <span class="string">'config.ini'</span>, <span class="string">'foo.py'</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; [name <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> fnmatch(name, <span class="string">'Dat*.csv'</span>)]</span></span><br><span class="line">['Dat1.csv', 'Dat2.csv']</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><code>fnmatch()</code> 函数使用底层操作系统的大小写敏感规则(不同的系统是不一样的)来匹配模式。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># On OS X (Mac)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.TXT'</span>)</span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># On Windows</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.TXT'</span>)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你对这个区别很在意，可以使用 <code>fnmatchcase()</code> 来代替。它完全使用你的模式大小写匹配。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; fnmatchcase(<span class="string">'foo.txt'</span>, <span class="string">'*.TXT'</span>)</span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>这两个函数通常会被忽略的一个特性是在处理非文件名的字符串时候它们也是很有用的。比如，假设你有一个街道地址的列表数据：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addresses = [</span><br><span class="line">    '<span class="number">5412</span> N CLARK ST',</span><br><span class="line">    '<span class="number">1060</span> W ADDISON ST',</span><br><span class="line">    '<span class="number">1039</span> W GRANVILLE AVE',</span><br><span class="line">    '<span class="number">2122</span> N CLARK ST',</span><br><span class="line">    '<span class="number">4802</span> N BROADWAY',</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>你可以像这样写列表推导：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatchcase</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[addr <span class="keyword">for</span> addr <span class="keyword">in</span> addresses <span class="keyword">if</span> fnmatchcase(addr, <span class="string">'* ST'</span>)]</span><br><span class="line">[<span class="string">'5412 N CLARK ST'</span>, <span class="string">'1060 W ADDISON ST'</span>, <span class="string">'2122 N CLARK ST'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[addr <span class="keyword">for</span> addr <span class="keyword">in</span> addresses <span class="keyword">if</span> fnmatchcase(addr, <span class="string">'54[0-9][0-9] *CLARK*'</span>)]</span><br><span class="line">[<span class="string">'5412 N CLARK ST'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>fnmatch()</code> 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。</p><p>如果你的代码需要做文件名的匹配，最好使用 <code>glob</code> 模块。参考 <code>5.13 小节</code>。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.04 字符串匹配和搜索</title>
      <link href="/2018-06-08/2-04-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
      <url>/2018-06-08/2-04-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%92%8C%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想匹配或者搜索特定模式的文本<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果你想匹配的是字面字符串，那么你通常只需要调用基本字符串方法就行， 比如 <code>str.find()、str.endswith()、str.startswith()</code>或者类似的方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; text = <span class="string">'yeah, but no, but yeah, but no, but yeah'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Exact match</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; text == <span class="string">'yeah'</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Match at start or end</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; text.startswith(<span class="string">'yeah'</span>)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; text.endswith(<span class="string">'no'</span>)</span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Search for the location of the first occurrence</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; text.find(<span class="string">'no'</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>对于复杂的匹配需要使用正则表达式和 <code>re</code> 模块。为了解释正则表达式的基本原理，假设你想匹配数字格式的日期字符串比如<code>11/27/2012</code>，你可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">'11/27/2012'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'Nov 27, 2012'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Simple matching: \d+ means match one or more digits</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> re.match(<span class="string">r'\d+/\d+/\d+'</span>, text1):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'no'</span>)</span><br><span class="line">...</span><br><span class="line">yes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> re.match(<span class="string">r'\d+/\d+/\d+'</span>, text2):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'no'</span>)</span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果你想使用同一个模式去做多次匹配，你应该先将模式字符串预编译为模式对象。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.compile(<span class="string">r'\d+/\d+/\d+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> datepat.match(text1):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'no'</span>)</span><br><span class="line">...</span><br><span class="line">yes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> datepat.match(text2):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'no'</span>)</span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>match()</code> 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置， 使用 <code>findall()</code> 方法去代替。比如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = 'Today is <span class="number">11</span>/<span class="number">27</span>/<span class="number">2012.</span> PyCon starts <span class="number">3</span>/<span class="number">13</span>/<span class="number">2013.</span>'</span><br><span class="line">&gt;&gt;&gt; datepat.findall(text)</span><br><span class="line">['<span class="number">11</span>/<span class="number">27</span>/<span class="number">2012</span>', '<span class="number">3</span>/<span class="number">13</span>/<span class="number">2013</span>']</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在定义正则式的时候，通常会利用括号去捕获分组。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.compile(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>捕获分组可以使得后面的处理更加简单，因为可以分别将每个组的内容提取出来。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; m = datepat.match(<span class="string">'11/27/2012'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x1005d2750</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Extract the contents of each group</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">'11/27/2012'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m.group(<span class="number">2</span>)</span><br><span class="line"><span class="string">'27'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m.group(<span class="number">3</span>)</span><br><span class="line"><span class="string">'2012'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m.groups()</span><br><span class="line">(<span class="string">'11'</span>, <span class="string">'27'</span>, <span class="string">'2012'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; month, day, year = m.groups()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Find all matches (notice splitting into tuples)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; text</span><br><span class="line"><span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; datepat.findall(text)</span><br><span class="line">[(<span class="string">'11'</span>, <span class="string">'27'</span>, <span class="string">'2012'</span>), (<span class="string">'3'</span>, <span class="string">'13'</span>, <span class="string">'2013'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; for month, day, year in datepat.findall(text)<span class="symbol">:</span></span><br><span class="line">...     print(<span class="string">'&#123;&#125;-&#123;&#125;-&#123;&#125;'</span>.format(year, month, day))</span><br><span class="line">...</span><br><span class="line"><span class="number">2012</span>-<span class="number">11</span>-<span class="number">27</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">3</span>-<span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p><code>findall()</code> 方法会搜索文本并以列表形式返回所有的匹配。如果你想以迭代方式返回匹配，可以使用 <code>finditer()</code> 方法来代替，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> m <span class="keyword">in</span> datepat.finditer(text):</span><br><span class="line"><span class="meta">... </span>    print(m.groups())</span><br><span class="line">...</span><br><span class="line">(<span class="string">'11'</span>, <span class="string">'27'</span>, <span class="string">'2012'</span>)</span><br><span class="line">(<span class="string">'3'</span>, <span class="string">'13'</span>, <span class="string">'2013'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>关于正则表达式理论的教程已经超出了本书的范围。 不过，这一节阐述了使用 <code>re</code> 模块进行匹配和搜索文本的最基本方法。 核心步骤就是先使用 <code>re.compile()</code> 编译正则表达式字符串， 然后使用<code>match()</code>、 <code>findall()</code> 或者 <code>finditer()</code> 等方法。</p><p>当写正则式字符串的时候，相对普遍的做法是使用原始字符串比如 <code>r&#39;(\d+)/(\d+)/(\d+)&#39;</code>。这种字符串将不去解析反斜杠，这在正则表达式中是很有用的。 如果不这样做的话，你必须使用两个反斜杠，类似 <code>&#39;(\\d+)/(\\d+)/(\\d+)&#39;</code>。</p><p>需要注意的是 <code>match()</code> 方法仅仅检查字符串的开始部分。它的匹配结果有可能并不是你期望的那样。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; m = datepat.match(<span class="string">'11/27/2012abcdef'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x1005d27e8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; m.group()</span><br><span class="line"><span class="string">'11/27/2012'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想精确匹配，确保你的正则表达式以 <code>$</code> 结尾，就像这么这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.compile(<span class="string">r'(\d+)/(\d+)/(\d+)$'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat.match(<span class="string">'11/27/2012abcdef'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat.match(<span class="string">'11/27/2012'</span>)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x1005d2750</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>最后，如果你仅仅是做一次简单的文本匹配（搜索操作）的话，可以略过编译部分，直接使用 <code>re</code> 模块级别的函数。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, text)</span><br><span class="line">[(<span class="string">'11'</span>, <span class="string">'27'</span>, <span class="string">'2012'</span>), (<span class="string">'3'</span>, <span class="string">'13'</span>, <span class="string">'2013'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，如果你打算做大量的匹配和搜索操作的话，最好先编译正则表达式，然后再重复使用它。模块级别的函数会将最近编译过的模式缓存起来，因此并不会消耗太多的性能，但是如果使用预编译模式的话，你将会减少查找和一些额外的处理损耗。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.05 字符串搜索和替换</title>
      <link href="/2018-06-07/2-05-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2/"/>
      <url>/2018-06-07/2-05-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想在字符串中搜索和匹配指定的文本模式<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于简单的字面模式，直接使用 <code>str.replace()</code> 方法即可，比如：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">text</span> = <span class="comment">'yeah, but no, but yeah, but no, but yeah'</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">text</span>.replace(<span class="comment">'yeah', 'yep')</span></span><br><span class="line"><span class="comment">'yep, but no, but yep, but no, but yep'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>对于复杂的模式，请使用 <code>re</code> 模块中的 <code>sub()</code> 函数。为了说明这个，假设你想将形式为 <code>11/27/2012</code> 的日期字符串改成 <code>2012-11-27</code> 。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>sub()</code> 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 <code>\3</code> 指向前面模式的捕获组号。</p><p>如果你打算用相同的模式做多次替换，考虑先编译它来提升性能。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.compile(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat.sub(<span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>对于更加复杂的替换，可以传递一个替换回调函数来代替，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from calendar import month_abbr</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">change_date</span><span class="params">(m)</span></span><span class="symbol">:</span></span><br><span class="line">...     mon_name = month_abbr[int(m.group(<span class="number">1</span>))]</span><br><span class="line">...     <span class="keyword">return</span> <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(m.group(<span class="number">2</span>), mon_name, m.group(<span class="number">3</span>))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; datepat.sub(change_date, text)</span><br><span class="line"><span class="string">'Today is 27 Nov 2012. PyCon starts 13 Mar 2013.'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>一个替换回调函数的参数是一个 <code>match</code> 对象，也就是 <code>match()</code> 或者 <code>find()</code> 返回的对象。 使用 <code>group()</code> 方法来提取特定的匹配部分。回调函数最后返回替换字符串。</p><p>如果除了替换后的结果外，你还想知道有多少替换发生了，可以使用 <code>re.subn()</code> 来代替。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>newtext, n = datepat.subn(<span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newtext</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>关于正则表达式搜索和替换，上面演示的 <code>sub()</code> 方法基本已经涵盖了所有。其实最难的部分就是编写正则表达式模式，这个最好是留给读者自己去练习了。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.06 字符串忽略大小写的搜索替换</title>
      <link href="/2018-06-07/2-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2/"/>
      <url>/2018-06-07/2-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要以忽略大小写的方式搜索与替换文本字符串<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了在文本操作时忽略大小写，你需要在使用re模块的时候给这些操作提供 <code>re.IGNORECASE</code> 标志参数。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; text = <span class="string">'UPPER PYTHON, lower python, Mixed Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'python'</span>, text, flags=re.IGNORECASE)</span><br><span class="line">[<span class="string">'PYTHON'</span>, <span class="string">'python'</span>, <span class="string">'Python'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.sub(<span class="string">'python'</span>, <span class="string">'snake'</span>, text, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">'UPPER snake, lower snake, Mixed snake'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>最后的那个例子揭示了一个小缺陷，替换字符串并不会自动跟被匹配字符串的大小写保持一致。 为了修复这个，你可能需要一个辅助函数，就像下面的这样：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def matchcase(<span class="built_in">word</span>):</span><br><span class="line">    def <span class="built_in">replace</span>(m):</span><br><span class="line">        <span class="keyword">text</span> = m.group()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">text</span>.isupper():</span><br><span class="line">            <span class="literal">return</span> <span class="built_in">word</span>.<span class="built_in">upper</span>()</span><br><span class="line">        elif <span class="keyword">text</span>.islower():</span><br><span class="line">            <span class="literal">return</span> <span class="built_in">word</span>.<span class="built_in">lower</span>()</span><br><span class="line">        elif <span class="keyword">text</span>[<span class="number">0</span>].isupper():</span><br><span class="line">            <span class="literal">return</span> <span class="built_in">word</span>.capitalize()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="literal">return</span> <span class="built_in">word</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">replace</span></span><br></pre></td></tr></table></figure><p>下面是使用上述函数的方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.sub(<span class="string">'python'</span>, matchcase(<span class="string">'snake'</span>), text, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">'UPPER SNAKE, lower snake, Mixed Snake'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>译者注：<code>matchcase(&#39;snake&#39;)</code> 返回了一个回调函数(参数必须是 <code>match</code> 对象)，前面一节提到过，<code>sub()</code> 函数除了接受替换字符串外，还能接受一个回调函数。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>对于一般的忽略大小写的匹配操作，简单的传递一个 <code>re.IGNORECASE</code> 标志参数就已经足够了。但是需要注意的是，这个对于某些需要大小写转换的 <code>Unicode</code> 匹配可能还不够， 参考 <code>2.10小节</code> 了解更多细节。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.07 最短匹配模式</title>
      <link href="/2018-06-07/2-07-%E6%9C%80%E7%9F%AD%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018-06-07/2-07-%E6%9C%80%E7%9F%AD%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你正在试着用正则表达式匹配某个文本模式，但是它找到的是模式的最长可能匹配。而你想修改它变成查找最短的可能匹配。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个问题一般出现在需要匹配一对分隔符之间的文本的时候(比如引号包含的字符串)。 为了说明清楚，考虑如下的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat = re.compile(<span class="string">r'\"(.*)\"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">'Computer says "no."'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text1)</span><br><span class="line">[<span class="string">'no.'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'Computer says "no." Phone says "yes."'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text2)</span><br><span class="line">[<span class="string">'no." Phone says "yes.'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，模式 <code>r&#39;\&quot;(.*)\&quot;&#39;</code>的意图是匹配被双引号包含的文本。但是在正则表达式中 <code>*</code> 操作符是贪婪的，因此匹配操作会查找最长的可能匹配。于是在第二个例子中搜索 <code>text2</code> 的时候返回结果并不是我们想要的。</p><p>为了修正这个问题，可以在模式中的 <code>*</code> 操作符后面加上 <code>?</code> 修饰符，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat = re.compile(<span class="string">r'\"(.*?)\"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text2)</span><br><span class="line">[<span class="string">'no.'</span>, <span class="string">'yes.'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这样就使得匹配变成非贪婪模式，从而得到最短的匹配，也就是我们想要的结果。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>这一节展示了在写包含点 <code>(.)</code> 字符的正则表达式的时候遇到的一些常见问题。在一个模式字符串中，点 <code>(.)</code>匹配除了换行外的任何字符。然而，如果你将点 <code>(.)</code> 号放在开始与结束符(比如引号)之间的时候，那么匹配操作会查找符合模式的最长可能匹配。这样通常会导致很多中间的被开始与结束符包含的文本被忽略掉，并最终被包含在匹配结果字符串中返回。通过在 <code>*</code> 或者 <code>+</code>这样的操作符后面添加一个 <code>?</code> 可以强制匹配算法改成寻找最短的可能匹配。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.08 多行匹配模式</title>
      <link href="/2018-06-07/2-08-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018-06-07/2-08-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你正在试着使用正则表达式去匹配一大块的文本，而你需要跨越多行去匹配。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个问题很典型的出现在当你用点<code>(.)</code>去匹配任意字符的时候，忘记了点<code>(.)</code>不能匹配换行符的事实。比如，假设你想试着去匹配 <code>C</code>语言分割的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment = re.compile(<span class="string">r'/\*(.*?)\*/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">'/* this is a comment */'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'''/* this is a</span></span><br><span class="line"><span class="string"><span class="meta">... </span>multiline comment */</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment.findall(text1)</span><br><span class="line">[<span class="string">' this is a comment '</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment.findall(text2)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>为了修正这个问题，你可以修改模式字符串，增加对换行的支持。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment = re.compile(<span class="string">r'/\*((?:.|\n)*?)\*/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment.findall(text2)</span><br><span class="line">[<span class="string">' this is a\n multiline comment '</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在这个模式中， <code>(?:.|\n)</code> 指定了一个非捕获组 (也就是它定义了一个仅仅用来做匹配，而不能通过单独捕获或者编号的组)。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>re.compile()</code> 函数接受一个标志参数叫 <code>re.DOTALL</code> ，在这里非常有用。它可以让正则表达式中的点 <code>(.)</code> 匹配包括换行符在内的任意字符。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment = re.compile(<span class="string">r'/\*(.*?)\*/'</span>, re.DOTALL)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment.findall(text2)</span><br><span class="line">[<span class="string">' this is a\n multiline comment '</span>]</span><br></pre></td></tr></table></figure><p>对于简单的情况使用 <code>re.DOTALL</code> 标记参数工作的很好，但是如果模式非常复杂或者是为了构造字符串令牌而将多个模式合并起来( <code>2.18 节</code> 有详细描述)，这时候使用这个标记参数就可能出现一些问题。如果让你选择的话，最好还是定义自己的正则表达式模式，这样它可以在不需要额外的标记参数下也能工作的很好。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.09 将 Unicode 文本标准化</title>
      <link href="/2018-06-07/2-09-%E5%B0%86-Unicode-%E6%96%87%E6%9C%AC%E6%A0%87%E5%87%86%E5%8C%96/"/>
      <url>/2018-06-07/2-09-%E5%B0%86-Unicode-%E6%96%87%E6%9C%AC%E6%A0%87%E5%87%86%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你正在处理 <code>Unicode</code> 字符串，需要确保所有字符串在底层有相同的表示。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 <code>Unicode</code> 中，某些字符能够用多个合法的编码表示。为了说明，考虑下面的这个例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s1 = <span class="string">'Spicy Jalape\u00f1o'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s2 = <span class="string">'Spicy Jalapen\u0303o'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s1</span><br><span class="line"><span class="string">'Spicy Jalapeño'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s2</span><br><span class="line"><span class="string">'Spicy Jalapeño'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s1 == s2</span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; len(s1)</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; len(s2)</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>这里的文本<code>Spicy Jalapeño</code>使用了两种形式来表示。 第一种使用整体字符 <code>ñ(U+00F1)</code>，第二种使用拉丁字母 <code>n</code> 后面跟一个 <code>~</code> 的组合字符 (<code>U+0303</code>)。</p><p>在需要比较字符串的程序中使用字符的多种表示会产生问题。为了修正这个问题，你可以使用 <code>unicodedata</code> 模块先将文本标准化：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import unicodedata</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; t1 = unicodedata.normalize(<span class="string">'NFC'</span>, s1)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; t2 = unicodedata.normalize(<span class="string">'NFC'</span>, s2)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; t1 == t2</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(ascii(t1))</span><br><span class="line"><span class="string">'Spicy Jalape\xf1o'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; t3 = unicodedata.normalize(<span class="string">'NFD'</span>, s1)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; t4 = unicodedata.normalize(<span class="string">'NFD'</span>, s2)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; t3 == t4</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(ascii(t3))</span><br><span class="line"><span class="string">'Spicy Jalapen\u0303o'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p><code>normalize()</code>第一个参数指定字符串标准化的方式。 <code>NFC</code> 表示字符应该是整体组成(比如可能的话就使用单一编码)，而 <code>NFD</code> 表示字符应该分解为多个组合字符表示。</p><p><code>Python</code> 同样支持扩展的标准化形式 <code>NFKC</code> 和 <code>NFKD</code> ，它们在处理某些字符的时候增加了额外的兼容特性。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'\ufb01'</span> <span class="comment"># A single character</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s</span><br><span class="line"><span class="string">'ﬁ'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; unicodedata.normalize(<span class="string">'NFD'</span>, s)</span><br><span class="line"><span class="string">'ﬁ'</span></span><br><span class="line"><span class="comment"># Notice how the combined letters are broken apart here</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; unicodedata.normalize(<span class="string">'NFKD'</span>, s)</span><br><span class="line"><span class="string">'fi'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; unicodedata.normalize(<span class="string">'NFKC'</span>, s)</span><br><span class="line"><span class="string">'fi'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>标准化对于任何需要以一致的方式处理 <code>Unicode</code> 文本的程序都是非常重要的。当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。</p><p>在清理和过滤文本的时候字符的标准化也是很重要的。比如，假设你想清除掉一些文本上面的变音符的时候(可能是为了搜索和匹配)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t1 = unicodedata.normalize(<span class="string">'NFD'</span>, s1)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="string">''</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> t1 <span class="keyword">if</span> not unicodedata.combining(c))</span></span><br><span class="line">'Spicy Jalapeno'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>最后一个例子展示了 <code>unicodedata</code> 模块的另一个重要方面，也就是测试字符类的工具函数。<code>combining()</code> 函数可以测试一个字符是否为和音字符。在这个模块中还有其他函数用于查找字符类别，测试是否为数字字符等等。</p><p><code>Unicode</code> 显然是一个很大的主题。如果想更深入的了解关于标准化方面的信息， 请参考 <code>Unicode</code> 官网中关于这部分的说明 <code>Ned Batchelder</code> 在他的网站上对 <code>Python</code> 的 <code>Unicode</code> 处理问题也有一个很好的介绍。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.10 在正则式中使用 Unicode</title>
      <link href="/2018-06-07/2-10-%E5%9C%A8%E6%AD%A3%E5%88%99%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-Unicode/"/>
      <url>/2018-06-07/2-10-%E5%9C%A8%E6%AD%A3%E5%88%99%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-Unicode/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你正在使用正则表达式处理文本，但是关注的是 <code>Unicode</code> 字符处理。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>默认情况下 <code>re</code> 模块已经对一些 <code>Unicode</code> 字符类有了基本的支持。 比如，<code>\\d</code>已经匹配任意的 <code>unicode</code> 数字字符了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import re</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; num = re.compile(<span class="string">'\d+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># ASCII digits</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; num.match(<span class="string">'123'</span>)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x1007d9ed0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Arabic digits</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; num.match(<span class="string">'\u0661\u0662\u0663'</span>)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x101234030</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想在模式中包含指定的 <code>Unicode</code> 字符，你可以使用 <code>Unicode</code> 字符对应的转义序列(比如 <code>\uFFF</code> 或者 <code>\UFFFFFFF</code> )。比如，下面是一个匹配几个不同阿拉伯编码页面中所有字符的正则表达式：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; arabic = re.compile('[<span class="symbol">\u</span>0600-<span class="symbol">\u</span>06ff<span class="symbol">\u</span>0750-<span class="symbol">\u</span>077f<span class="symbol">\u</span>08a0-<span class="symbol">\u</span>08ff]+')</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>当执行匹配和搜索操作的时候，最好是先标准化并且清理所有文本为标准化格式(参考 <code>2.9小节</code> )。但是同样也应该注意一些特殊情况，比如在忽略大小写匹配和大小写转换时的行为。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; pat = re.compile(<span class="string">'stra\u00dfe'</span>, re.IGNORECASE)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'straße'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; pat.match(s) <span class="comment"># Matches</span></span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x10069d370</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; pat.match(s.upper()) <span class="comment"># Doesn't match</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.upper() <span class="comment"># Case folds</span></span><br><span class="line"><span class="string">'STRASSE'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>混合使用 <code>Unicode</code> 和正则表达式通常会让你抓狂。如果你真的打算这样做的话，最好考虑下安装第三方正则式库，它们会为 <code>Unicode</code> 的大小写转换和其他大量有趣特性提供全面的支持，包括模糊匹配。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 字符串和文本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>7.01 可接受任意数量参数的函数</title>
      <link href="/2018-06-07/7-01-%E5%8F%AF%E6%8E%A5%E5%8F%97%E4%BB%BB%E6%84%8F%E6%95%B0%E9%87%8F%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2018-06-07/7-01-%E5%8F%AF%E6%8E%A5%E5%8F%97%E4%BB%BB%E6%84%8F%E6%95%B0%E9%87%8F%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="第七章：函数"><a href="#第七章：函数" class="headerlink" title="第七章：函数"></a>第七章：函数</h3><p>使用 <code>def</code> 语句定义函数是所有程序的基础。本章的目标是讲解一些更加高级和不常见的函数定义与使用模式。涉及到的内容包括默认参数、任意数量参数、强制关键字参数、注解和闭包。另外，一些高级的控制流和利用回调函数传递数据的技术在这里也会讲解到。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想构造一个可接受任意数量参数的函数。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了能让一个函数接受任意数量的位置参数，可以使用一个 <code>*</code> 参数。例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">avg</span>(<span class="keyword">first</span>, *rest):</span><br><span class="line">    <span class="literal">return</span> (<span class="keyword">first</span> + <span class="built_in">sum</span>(rest)) / (<span class="number">1</span> + <span class="built_in">len</span>(rest))</span><br><span class="line"><span class="comment"># Sample use</span></span><br><span class="line"><span class="built_in">avg</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 1.5</span></span><br><span class="line"><span class="built_in">avg</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 2.5</span></span><br></pre></td></tr></table></figure><p>在这个例子中， <code>rest</code> 是由所有其他位置参数组成的元组。然后我们在代码中把它当成了一个序列来进行后续的计算。</p><p>为了接受任意数量的关键字参数，使用一个以 <code>**</code> 开头的参数。比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import html</span><br><span class="line"></span><br><span class="line">def make_element(name, <span class="built_in">value</span>, **attrs):</span><br><span class="line">    keyvals = [<span class="string">' %s="%s"'</span> % <span class="keyword">item</span> <span class="keyword">for</span> <span class="keyword">item</span> <span class="keyword">in</span> attrs.<span class="keyword">items</span>()]</span><br><span class="line">    print(keyvals)</span><br><span class="line">    attr_str = <span class="string">''</span>.join(keyvals)</span><br><span class="line">    <span class="keyword">element</span> = <span class="string">'&lt;&#123;name&#125;&#123;attrs&#125;&gt;&#123;value&#125;&lt;/&#123;name&#125;&gt;'</span>.<span class="built_in">format</span>(</span><br><span class="line">                name=name,</span><br><span class="line">                attrs=attr_str,</span><br><span class="line">                <span class="built_in">value</span>=html.escape(<span class="built_in">value</span>))</span><br><span class="line">    <span class="literal">return</span> <span class="keyword">element</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="comment"># Creates '&lt;item size="large" quantity="6"&gt;Albatross&lt;/item&gt;'</span></span><br><span class="line">make_element(<span class="string">'item'</span>, <span class="string">'Albatross'</span>, size=<span class="string">'large'</span>, quantity=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates '&lt;p&gt;&amp;lt;spam&amp;gt;&lt;/p&gt;'</span></span><br><span class="line">make_element(<span class="string">'p'</span>, <span class="string">'&lt;spam&gt;'</span>)</span><br></pre></td></tr></table></figure><p>在这里， <code>attrs</code> 是一个包含所有被传入进来的关键字参数的字典。</p><p>如果你还希望某个函数能同时接受任意数量的位置参数和关键字参数，可以同时使用 <code>*</code> 和 <code>**</code> 。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anyargs</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(args) <span class="comment"># A tuple</span></span><br><span class="line">    print(kwargs) <span class="comment"># A dict</span></span><br></pre></td></tr></table></figure><p>使用这个函数时，所有位置参数会被放到 <code>args</code> 元组中，所有关键字参数会被放到字典 <code>kwargs</code> 中。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>一个 <code>*</code>参数只能出现在函数定义中最后一个位置参数后面，而 <code>**</code>参数只能出现在最后一个参数。有一点要注意的是，在 <code>*</code> 参数后面仍然可以定义其他参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x, *args, y)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(x, *args, y, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这种参数就是我们所说的强制关键字参数，在后面 <code>7.2 小节</code> 还会详细讲解到。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 字符串表达式 eval 函数的使用</title>
      <link href="/2018-06-07/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E8%BE%BE%E5%BC%8F-eval-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018-06-07/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E8%BE%BE%E5%BC%8F-eval-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><code>eval()</code> 函数用来执行一个字符串表达式，并返回表达式的值。</p><p><code>eval(expression[, globals[, locals]])</code><br>比如对于用户的输入数字，判断其类型。（也可以用 <code>str.isdigit()</code> 函数）</p><p>比如将 <code>string</code> 转化为 <code>list、tuple、dict</code> 。<br><a id="more"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">help</span>(str.isdigit)</span></span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">isdigit(...)</span><br><span class="line">    S.isdigit() -&gt; bool</span><br><span class="line"></span><br><span class="line">    Return True if all characters in S are digits</span><br><span class="line">    and there is at least one character in S, False otherwise.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="string">'12'</span>.isdigit()</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="string">'12.00'</span>.isdigit()</span></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'123'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(a)</span></span><br><span class="line">123</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(<span class="string">'a'</span>)</span></span><br><span class="line">'123'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(<span class="built_in">eval</span>(a))</span></span><br><span class="line">&lt;class 'int'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">'a'</span>))</span></span><br><span class="line">&lt;class 'str'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'123.123'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(b)</span></span><br><span class="line">123.123</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(<span class="built_in">eval</span>(b))</span></span><br><span class="line">&lt;class 'float'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(<span class="string">'3 * 4'</span>)</span></span><br><span class="line">12</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(<span class="string">'3 ** c'</span>)</span></span><br><span class="line">243</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; d = <span class="string">"[[1,2], [3,4], [5,6], [7,8], [9,0]]"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(d)</span></span><br><span class="line">[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; e = <span class="string">"&#123;1: 'a', 2: 'b'&#125;"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(e)</span></span><br><span class="line">&#123;1: 'a', 2: 'b'&#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f = <span class="string">"([1,2], [3,4], [5,6], [7,8], (9,0))"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">eval</span>(f)</span></span><br><span class="line">([1, 2], [3, 4], [5, 6], [7, 8], (9, 0))</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>参照：</p><ul><li><a href="https://blog.csdn.net/zhanh1218/article/details/37562167" target="_blank" rel="noopener">Python:eval的妙用和滥用</a></li><li><a href="http://www.jb51.net/article/128410.htm" target="_blank" rel="noopener">详解Python eval函数的妙用</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 内置函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 字符串格式化方法 format 函数的使用</title>
      <link href="/2018-06-07/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95-format-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018-06-07/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95-format-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><code>Python</code> 从 <code>2.6</code> 开始支持 <code>format</code> ，更加容易读懂的字符串格式化方法，改变原来的 <code>%</code> 模式</p><h3 id="format-格式说明"><a href="#format-格式说明" class="headerlink" title="format 格式说明"></a><code>format</code> 格式说明</h3><p>花括号声明 <code>{}</code>、用于渲染前的参数引用声明，花括号里可以用数字代表引用参数的序号， 或者变量名直接引用。</p><p>从 <code>format</code> 参数引入的变量名</p><ul><li><p>冒号 <code>：</code></p></li><li><p>字符位数声明</p></li><li><p>空白自动填补符的声明</p></li><li><p>千分位的声明</p></li><li><p>变量类型的声明： 字符串 <code>s</code> 、数字 <code>d</code> 、浮点数 <code>f</code></p></li><li><p>对齐方向符号<code>&lt; ^ &gt;</code></p></li><li><p>属性访问符中括号 <code>[]</code></p></li><li><p>使用惊叹号<code>！</code>后接 <code>a 、r、 s</code> ，声明 是使用何种模式： <code>acsii</code> 模式 、引用 <code>__repr__</code> 或 <code>__str__</code></p></li><li><p>增加类魔法函数 <code>__format__(self, format)</code> ，可以根据 <code>format</code> 前的字符串格式来定制不同的显示， 如：<code>{：xxxx}</code> 此时 <code>xxxx</code> 会作为参数传入 <code>__format__</code> 函数中。</p></li></ul><a id="more"></a><h3 id="花括号声明-、-用于渲染前的参数引用声明，花括号里可以用数字代表引用参数的序号，-或者变量名直接引用。"><a href="#花括号声明-、-用于渲染前的参数引用声明，花括号里可以用数字代表引用参数的序号，-或者变量名直接引用。" class="headerlink" title="花括号声明 {} 、 用于渲染前的参数引用声明，花括号里可以用数字代表引用参数的序号， 或者变量名直接引用。"></a>花括号声明 <code>{}</code> 、 用于渲染前的参数引用声明，花括号里可以用数字代表引用参数的序号， 或者变量名直接引用。</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> </span><br><span class="line"><span class="string">'&#123;&#125; &#123;&#125;'</span>.format(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br><span class="line"><span class="string">'&#123;1&#125; &#123;0&#125;'</span>.format(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br><span class="line"></span><br><span class="line">Outpu<span class="variable">t:</span></span><br><span class="line"><span class="string">'one two'</span></span><br><span class="line"><span class="string">'two one'</span></span><br><span class="line"></span><br><span class="line">Inpu<span class="variable">t:</span> </span><br><span class="line">data = &#123;<span class="string">'first'</span>: <span class="string">'Hodor'</span>, <span class="string">'last'</span>: <span class="string">'Hodor!'</span>&#125;</span><br><span class="line"><span class="string">'%(first)s %(last)s'</span> % data</span><br><span class="line"><span class="string">'&#123;first&#125; &#123;last&#125;'</span>.format(**data)</span><br><span class="line"></span><br><span class="line">Outpu<span class="variable">t:</span></span><br><span class="line"><span class="string">'Hodor Hodor!'</span></span><br><span class="line"><span class="string">'Hodor Hodor!'</span></span><br></pre></td></tr></table></figure><h3 id="千分位、浮点数、填充字符、对齐的组合使用"><a href="#千分位、浮点数、填充字符、对齐的组合使用" class="headerlink" title="千分位、浮点数、填充字符、对齐的组合使用"></a>千分位、浮点数、填充字符、对齐的组合使用</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># :冒号 + 空白填充 + 右对齐 + 固定宽度18 + 千分位 + 浮点精度.2 + 浮点数声明 f</span></span><br><span class="line"><span class="symbol">Input:</span></span><br><span class="line"><span class="string">'&#123;:&gt;18,.2f&#125;'</span>.format(<span class="number">70305084.0</span>)     </span><br><span class="line"><span class="symbol">Output:</span></span><br><span class="line"><span class="string">'     70,305,084.00'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:.5&#125;'</span>.format(<span class="string">'xylophone'</span>)</span><br><span class="line"><span class="string">'xylop'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:^10&#125;'</span>.format(<span class="string">'test'</span>)</span><br><span class="line"><span class="string">'   test   '</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:.&#123;&#125;&#125;'</span>.format(<span class="string">'xylophone'</span>, <span class="number">7</span>)</span><br><span class="line"><span class="string">'xylopho'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:4d&#125;'</span>.format(<span class="number">42</span>)</span><br><span class="line"><span class="string">'  42'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:06.2f&#125;'</span>.format(<span class="number">3.141592653589793</span>)</span><br><span class="line"><span class="string">'003.14'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:+d&#125;'</span>.format(<span class="number">42</span>)</span><br><span class="line"><span class="string">'+42'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="属性访问符中括号"><a href="#属性访问符中括号" class="headerlink" title="属性访问符中括号 []"></a>属性访问符中括号 <code>[]</code></h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Input</span>:</span><br><span class="line"><span class="class"><span class="keyword">data</span> = [4, 8, 15, 16, 23, 42]</span></span><br><span class="line">'&#123;d[<span class="number">4</span>]&#125; &#123;d[<span class="number">5</span>]&#125;'.format(d=<span class="class"><span class="keyword">data</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Output</span>:</span><br><span class="line">'<span class="number">23</span> <span class="number">42</span>'</span><br></pre></td></tr></table></figure><h3 id="复杂数据格式化"><a href="#复杂数据格式化" class="headerlink" title="复杂数据格式化"></a>复杂数据格式化</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">class Plant(object):</span><br><span class="line"><span class="code">    type = 'tree'</span></span><br><span class="line"><span class="code">    kinds = [&#123;'name': 'oak'&#125;, &#123;'name': 'maple'&#125;]</span></span><br><span class="line">'&#123;p.type&#125;: &#123;p.kinds[<span class="string">0</span>][<span class="symbol">name</span>]&#125;'.format(p=Plant())</span><br><span class="line"></span><br><span class="line">Output:tree: oak</span><br></pre></td></tr></table></figure><h3 id="惊叹号-！-限定访问-repr-等魔法函数"><a href="#惊叹号-！-限定访问-repr-等魔法函数" class="headerlink" title="惊叹号 ！ 限定访问 repr 等魔法函数"></a>惊叹号 <code>！</code> 限定访问 <code>repr</code> 等魔法函数</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Data</span>(<span class="title">object</span>):</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">...             <span class="keyword">return</span> <span class="string">'str'</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">...             <span class="keyword">return</span> <span class="string">'repr'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'%s %r'</span> % (Data(), Data())</span><br><span class="line"><span class="string">'str repr'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;0!s&#125; &#123;0!r&#125;'</span>.format(Data())</span><br><span class="line"><span class="string">'str repr'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="增加类魔法函数-format-self-format"><a href="#增加类魔法函数-format-self-format" class="headerlink" title="增加类魔法函数 __format__(self, format)"></a>增加类魔法函数 <code>__format__(self, format)</code></h3><p>根据 <code>format</code> 前的字符串格式来定制不同的显示， 如：<code>{：xxxx}</code> 此时 <code>xxxx</code> 会作为参数传入 <code>__format__</code> 函数中。 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">HAL9000</span>(<span class="title">object</span>):</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(<span class="keyword">self</span>, format)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">if</span> (format == <span class="string">'open-the-pod-bay-doors'</span>)<span class="symbol">:</span></span><br><span class="line">...             <span class="keyword">return</span> <span class="string">"I'm afraid I can't do that."</span></span><br><span class="line">...         <span class="keyword">return</span> <span class="string">'HAL 9000'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:open-the-pod-bay-doors&#125;'</span>.format(HAL900<span class="number">0</span>())</span><br><span class="line"><span class="string">"I'm afraid I can't do that."</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line">时间日期的特例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from datetime import datetime</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'&#123;:%Y-%m-%d %H:%M&#125;'</span>.format(datetime(<span class="number">2001</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="string">'2001-02-03 04:05'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/ToDoToTry/p/5635863.html" target="_blank" rel="noopener">Python 字符串格式化方法 format 函数的使用</a></li><li><a href="https://pyformat.info/" target="_blank" rel="noopener">https://pyformat.info/</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 内置函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python any 函数与 all 函数</title>
      <link href="/2018-06-07/Python-any-%E5%87%BD%E6%95%B0%E4%B8%8E-all-%E5%87%BD%E6%95%B0/"/>
      <url>/2018-06-07/Python-any-%E5%87%BD%E6%95%B0%E4%B8%8E-all-%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="any-x-函数："><a href="#any-x-函数：" class="headerlink" title="any(x) 函数："></a><code>any(x)</code> 函数：</h3><p><code>any(x)</code>：只要 <code>x</code> 中有一个不为空 <code>【(&#39;&#39;)，0，false 】</code> 就返回 <code>True</code> ，否则返回 <code>False</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>(<span class="string">'123'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([<span class="number">0</span>,<span class="string">'0'</span>,<span class="string">''</span>])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([<span class="number">0</span>,<span class="string">''</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([<span class="number">0</span>,<span class="string">''</span>,<span class="string">'false'</span>])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([<span class="number">0</span>,<span class="string">''</span>,bool(<span class="string">'false'</span>)])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([<span class="number">0</span>,<span class="string">''</span>,<span class="keyword">False</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>((<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>((<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">''</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>((<span class="number">0</span>,<span class="keyword">False</span>,<span class="string">''</span>))</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>([])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">any</span>(())</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="all-x-函数"><a href="#all-x-函数" class="headerlink" title="all(x) 函数"></a><code>all(x)</code> 函数</h3><p><code>all(x)</code>：必须 <code>x</code> 中的所有元素均不为空 <code>【(&#39;&#39;)，0，false 】</code> 才会返回 <code>True</code> ，否则返回 <code>False</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])  <span class="comment"># 列表 list </span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])  <span class="comment"># 列表 list 元素都不为空或0</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>])  <span class="comment"># 列表 list 存在一个为空的元素</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all([<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 列表 list 存在一个为0的元素</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>))  <span class="comment"># 元组 tuple，元素都不为空或 0 </span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>))  <span class="comment"># 元组 tuple，存在一个为空的元素</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all((<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 元组 tuple，存在一个为 0 的元素</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all([]) <span class="comment"># 空列表</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all(()) <span class="comment"># 空元组</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># 注意：空元组、空列表返回值为 True，这里要特别注意</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all((<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>))  <span class="comment">#元组 tuple，全部为空的元素</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all(<span class="string">''</span>)</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># 如果 all(x) 参数 x 对象的所有元素不为 0、''、False 或者 x 为空对象，则返回 True，否则返回 False</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; all([None])</span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 内置函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 获取帮助信息</title>
      <link href="/2018-06-07/Python-%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF/"/>
      <url>/2018-06-07/Python-%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<ul><li><p><code>help()</code></p></li><li><p><code>dir()</code></p></li><li><p><code>_ doc_</code></p></li></ul><p>参照：</p><ul><li><a href="https://www.cnblogs.com/anliven/p/6022987.html" target="_blank" rel="noopener">Python - 获取帮助信息</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python IDLE 清屏问题的解决</title>
      <link href="/2018-06-07/Python-IDLE-%E6%B8%85%E5%B1%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2018-06-07/Python-IDLE-%E6%B8%85%E5%B1%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<p>首先下载 <a href="https://dongfei.oss-cn-shanghai.aliyuncs.com/books/ClearWindow.py" target="_blank" rel="noopener">clearwindow.py</a>（点击可直接下载），将这个文件放在 <code>Python X\Lib\idlelib</code> 目录下（ <code>X</code> 为你的 <code>Python</code> 版本），然后在这个目录下找到 <code>config-extensions.def</code> 这个文件（ <code>IDLE</code> 扩展的配置文件），以记事本的方式打开它（为防止出错，你可以在打开它之前先备份）。</p><p>打开 <code>config-extensions.def</code> 后在句末加上这样几句：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ClearWindow]</span></span><br><span class="line"><span class="attr">enable</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enable_editor</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">enable_shell</span>=<span class="number">1</span></span><br><span class="line"><span class="section">[ClearWindow_cfgBindings]</span></span><br><span class="line"><span class="attr">clear-window</span>=&lt;Control-Key-l&gt;</span><br></pre></td></tr></table></figure><p>然后保存退出就可以了。</p><p>打开 <code>Python</code> 的 <code>IDLE</code> ，看看 <code>options</code> 是不是多了一个选项 <code>clear shell window ctrl+L</code></p><p>如果是这样的话，那就证明你安装成功了，以后要清屏直接 <code>ctrl+L</code> 就可以了。</p><p>参考：</p><ul><li><a href="http://www.cnblogs.com/maybego/p/3234055.html" target="_blank" rel="noopener">python idle 清屏问题的解决</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Turtle 龟图形</title>
      <link href="/2018-06-07/Turtle-%E9%BE%9F%E5%9B%BE%E5%BD%A2/"/>
      <url>/2018-06-07/Turtle-%E9%BE%9F%E5%9B%BE%E5%BD%A2/</url>
      <content type="html"><![CDATA[<h3 id="乌龟运动"><a href="#乌龟运动" class="headerlink" title="乌龟运动"></a>乌龟运动</h3><h4 id="移动和绘制"><a href="#移动和绘制" class="headerlink" title="移动和绘制"></a>移动和绘制</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">forward</span><span class="params">()</span> | <span class="title">fd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">backward</span><span class="params">()</span> | <span class="title">bk</span><span class="params">()</span> | <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">right</span><span class="params">()</span> | <span class="title">rt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">left</span><span class="params">()</span> | <span class="title">lt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">goto</span><span class="params">()</span> | <span class="title">setpos</span><span class="params">()</span> | <span class="title">setposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">sety</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setheading</span><span class="params">()</span> | <span class="title">seth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">home</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">circle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">dot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">stamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">clearstamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">clearstamps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">undo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">speed</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="告诉乌龟的状态"><a href="#告诉乌龟的状态" class="headerlink" title="告诉乌龟的状态"></a>告诉乌龟的状态</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">position</span><span class="params">()</span> | <span class="title">pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">towards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">xcor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">ycor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">heading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="设置和测量"><a href="#设置和测量" class="headerlink" title="设置和测量"></a>设置和测量</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">degrees</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">radians</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="笔控制"><a href="#笔控制" class="headerlink" title="笔控制"></a>笔控制</h3><h4 id="绘图状态"><a href="#绘图状态" class="headerlink" title="绘图状态"></a>绘图状态</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pendown</span><span class="params">()</span> | <span class="title">pd</span><span class="params">()</span> | <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">penup</span><span class="params">()</span> | <span class="title">pu</span><span class="params">()</span> | <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">pensize</span><span class="params">()</span> | <span class="title">width</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">pen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">isdown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">color</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">pencolor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fillcolor</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">filling</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin_fill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">end_fill</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="更多绘图控制"><a href="#更多绘图控制" class="headerlink" title="更多绘图控制"></a>更多绘图控制</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="乌龟状态"><a href="#乌龟状态" class="headerlink" title="乌龟状态"></a>乌龟状态</h3><h4 id="能见度"><a href="#能见度" class="headerlink" title="能见度"></a>能见度</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">showturtle</span><span class="params">()</span> | <span class="title">st</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">hideturtle</span><span class="params">()</span> | <span class="title">ht</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">isvisible</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="出现"><a href="#出现" class="headerlink" title="出现"></a>出现</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shape</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">resizemode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shapesize</span><span class="params">()</span> | <span class="title">turtlesize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shearfactor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">settiltangle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">tiltangle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">tilt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shapetransform</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">get_shapepoly</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onclick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">onrelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">ondrag</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="特殊龟方法"><a href="#特殊龟方法" class="headerlink" title="特殊龟方法"></a>特殊龟方法</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">begin_poly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">end_poly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">get_poly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">getturtle</span><span class="params">()</span> | <span class="title">getpen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">getscreen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setundobuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">undobufferentries</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="TurtleScreen-Screen-的方法"><a href="#TurtleScreen-Screen-的方法" class="headerlink" title="TurtleScreen / Screen 的方法"></a><code>TurtleScreen / Screen</code> 的方法</h3><h4 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bgcolor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">bgpic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">clear</span><span class="params">()</span> | <span class="title">clearscreen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">reset</span><span class="params">()</span> | <span class="title">resetscreen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">screensize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setworldcoordinates</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">tracer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">update</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="使用屏幕事件"><a href="#使用屏幕事件" class="headerlink" title="使用屏幕事件"></a>使用屏幕事件</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">onkey</span><span class="params">()</span> | <span class="title">onkeyrelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">onkeypress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">onclick</span><span class="params">()</span> | <span class="title">onscreenclick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">ontimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">mainloop</span><span class="params">()</span> | <span class="title">done</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="设置和特殊方法"><a href="#设置和特殊方法" class="headerlink" title="设置和特殊方法"></a>设置和特殊方法</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">colormode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">getcanvas</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">getshapes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">register_shape</span><span class="params">()</span> | <span class="title">addshape</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">turtles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">window_height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">window_width</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">textinput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">numinput</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="筛选特异性方法"><a href="#筛选特异性方法" class="headerlink" title="筛选特异性方法"></a>筛选特异性方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bye</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">exitonclick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">title</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.rddoc.com/doc/Python/3.6.0/zh/library/turtle/#tell-turtle-s-state" target="_blank" rel="noopener"> 24.1. turtle — 龟图形</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3 替换 Python2 中 cmp 函数的新函数分析</title>
      <link href="/2018-06-07/Python3-%E6%9B%BF%E6%8D%A2-Python2-%E4%B8%AD-cmp-%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B0%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/"/>
      <url>/2018-06-07/Python3-%E6%9B%BF%E6%8D%A2-Python2-%E4%B8%AD-cmp-%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B0%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import operator</span><br><span class="line"></span><br><span class="line">operator.lt(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.le(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.eq(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.ne(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.ge(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.gt(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.__lt__(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.__le__(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.__eq__(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.__ne__(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.__ge__(<span class="selector-tag">a</span>, b)   </span><br><span class="line">operator.__gt__(<span class="selector-tag">a</span>, b)   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数的返回值是布尔类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">lt</span><span class="params">(a,b)</span></span> 相当于 a&lt;<span class="selector-tag">b</span>      从第一个数字或字母（ASCII）比大小 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">le</span><span class="params">(a,b)</span></span> 相当于 a&lt;=b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">eq</span><span class="params">(a,b)</span></span> 相当于 a==<span class="selector-tag">b</span>     字母完全一样，返回 True</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ne</span><span class="params">(a,b)</span></span> 相当于 a!=b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">gt</span><span class="params">(a,b)</span></span> 相当于 a&gt;b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ge</span><span class="params">(a,b)</span></span> 相当于 a&gt;=b</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://blog.csdn.net/sushengmiyan/article/details/11332589" target="_blank" rel="noopener">python3中替换python2中cmp函数的新函数分析(lt、le、eq、ne、ge、gt)</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
