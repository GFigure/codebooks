<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dongfei&#39;s Book</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codebooks.dongfei.xin/"/>
  <updated>2018-10-27T04:46:06.369Z</updated>
  <id>http://codebooks.dongfei.xin/</id>
  
  <author>
    <name>乔戈里</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 统计列表元素出现次数</title>
    <link href="http://codebooks.dongfei.xin/2018-10-27/Python-%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://codebooks.dongfei.xin/2018-10-27/Python-统计列表元素出现次数/</id>
    <published>2018-10-27T04:39:39.000Z</published>
    <updated>2018-10-27T04:46:06.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用列表-list-中的-count-来完成统计"><a href="#利用列表-list-中的-count-来完成统计" class="headerlink" title="利用列表 list 中的 count 来完成统计"></a>利用列表 list 中的 count 来完成统计</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_list</span><span class="params">(arr, target)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> arr.count(target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target=2，结果：3</span></span><br></pre></td></tr></table></figure><h3 id="利用字典-dict-来完成统计"><a href="#利用字典-dict-来完成统计" class="headerlink" title="利用字典 dict 来完成统计"></a>利用字典 dict 来完成统计</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">key</span> <span class="keyword">in</span> a:</span><br><span class="line">    dict[<span class="built_in">key</span>] = dict.<span class="built_in">get</span>(<span class="built_in">key</span>, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> dict</span><br></pre></td></tr></table></figure><h3 id="利用-collection-包下-Counter-的类"><a href="#利用-collection-包下-Counter-的类" class="headerlink" title="利用 collection 包下 Counter 的类"></a>利用 collection 包下 Counter 的类</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> collections import Counter</span><br><span class="line"><span class="keyword">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">result</span> = Counter(<span class="keyword">a</span>)</span><br><span class="line">print <span class="built_in">result</span></span><br><span class="line">print dict(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;利用列表-list-中的-count-来完成统计&quot;&gt;&lt;a href=&quot;#利用列表-list-中的-count-来完成统计&quot; class=&quot;headerlink&quot; title=&quot;利用列表 list 中的 count 来完成统计&quot;&gt;&lt;/a&gt;利用列表 list 中的 c
      
    
    </summary>
    
      <category term="其他" scheme="http://codebooks.dongfei.xin/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 在字典中根据条件筛选数据</title>
    <link href="http://codebooks.dongfei.xin/2018-09-22/Python-%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/"/>
    <id>http://codebooks.dongfei.xin/2018-09-22/Python-在字典中根据条件筛选数据/</id>
    <published>2018-09-22T15:15:43.000Z</published>
    <updated>2018-09-22T15:18:38.713Z</updated>
    
    <content type="html"><![CDATA[<p>首先创建一个字典</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">random</span></span><br><span class="line">import <span class="built_in">time</span></span><br><span class="line"></span><br><span class="line">d = &#123;str(x): <span class="built_in">random</span>.randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'16'</span>: <span class="number">61</span>, <span class="string">'3'</span>: <span class="number">66</span>, <span class="string">'17'</span>: <span class="number">70</span>, <span class="string">'10'</span>: <span class="number">82</span>, <span class="string">'1'</span>: <span class="number">71</span>, <span class="string">'18'</span>: <span class="number">89</span>, <span class="string">'5'</span>: <span class="number">83</span>, <span class="string">'4'</span>: <span class="number">97</span>, <span class="string">'19'</span>: <span class="number">77</span>, <span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'8'</span>: <span class="number">73</span>, <span class="string">'11'</span>: <span class="number">74</span>, <span class="string">'15'</span>: <span class="number">60</span>, <span class="string">'13'</span>: <span class="number">68</span>, <span class="string">'20'</span>: <span class="number">80</span>, <span class="string">'7'</span>: <span class="number">62</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'6'</span>: <span class="number">85</span>, <span class="string">'14'</span>: <span class="number">83</span>, <span class="string">'9'</span>: <span class="number">87</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>现有一个需求, 需要此列表中筛选出值大于 90 的 id(key) 都有哪些 ？</p><p>以下给出四种实现方式</p><h3 id="第一种方法-循环迭代"><a href="#第一种方法-循环迭代" class="headerlink" title="第一种方法: 循环迭代"></a>第一种方法: 循环迭代</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="keyword">if</span> d[k] &gt; <span class="number">90</span>:</span><br><span class="line">        d2[k] = d[k]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(d2)</span></span></span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126503</span></span><br><span class="line"><span class="number">1500951937.126532</span></span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000029</p><p>###第二种方法: filter 函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="name">time</span>.time())</span><br><span class="line">d5 = list(<span class="name">filter</span>(<span class="name">lambda</span> x: d[x] &gt; <span class="number">90</span>, d))</span><br><span class="line">print(<span class="name">time</span>.time())</span><br><span class="line">print(<span class="name">d5</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果为:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126604</span></span><br><span class="line"><span class="number">1500951937.126618</span></span><br><span class="line">[<span class="symbol">'4</span>', <span class="symbol">'12</span>', <span class="symbol">'2</span>']</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000014</p><h3 id="第三种方法-字典解析式"><a href="#第三种方法-字典解析式" class="headerlink" title="第三种方法: 字典解析式"></a>第三种方法: 字典解析式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line">d3 = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">90</span>&#125;</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(d3)</span></span></span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126555</span></span><br><span class="line"><span class="number">1500951937.126564</span></span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000009</p><h3 id="第四种方法-生成器表达式"><a href="#第四种方法-生成器表达式" class="headerlink" title="第四种方法: 生成器表达式"></a>第四种方法: 生成器表达式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line">d4 = (&#123;k: v&#125; <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">90</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(time.time()</span></span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> d4:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1500951937.126576</span></span><br><span class="line"><span class="number">1500951937.126581</span></span><br><span class="line">&#123;<span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>&#125;</span><br><span class="line">&#123;<span class="string">'2'</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure><p>得到结果需要的时间为: 0.000005</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>在字典数据量较小时，依然推荐使用字典解析式去筛选数据，在数据量较大且数据需要一条一条处理时，生成器依然是最佳的选择</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先创建一个字典&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import &lt;span class=&quot;built_in&quot;&gt;random&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &lt;span class=&quot;built_in&quot;&gt;time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d = &amp;#123;str(x): &lt;span class=&quot;built_in&quot;&gt;random&lt;/span&gt;.randint(&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(d)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果为:&lt;/p&gt;
&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;16&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;3&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;66&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;17&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;70&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;10&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;82&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;71&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;18&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;5&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;83&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;4&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;97&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;19&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;77&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;12&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;92&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;8&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;73&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;11&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;74&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;15&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;13&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;68&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;20&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;7&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;62&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;6&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;85&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;14&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;83&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;87&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="其他" scheme="http://codebooks.dongfei.xin/categories/Python/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Map 函数处理字典</title>
    <link href="http://codebooks.dongfei.xin/2018-09-22/Map-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%AD%97%E5%85%B8/"/>
    <id>http://codebooks.dongfei.xin/2018-09-22/Map-函数处理字典/</id>
    <published>2018-09-22T14:54:05.000Z</published>
    <updated>2018-09-22T15:16:06.219Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = dict(<span class="attribute">addr</span>=<span class="string">'china'</span>, <span class="attribute">name</span>=<span class="string">'samy'</span>)</span><br></pre></td></tr></table></figure><p>map 函数上述字典返回的是一个 list，那如何返回字典呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; map(lambda <span class="symbol">x:</span> x.upper(), a.values())</span><br><span class="line">[<span class="string">'CHINA'</span>, <span class="string">'SAMY'</span>]</span><br></pre></td></tr></table></figure><p>返回字典的方法：<br><a id="more"></a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = dict(name=<span class="string">'samy'</span>,addr=<span class="string">'china'</span>)</span><br><span class="line">&gt;&gt;&gt; dict(zip(<span class="selector-tag">a</span>, map(lambda x: x.upper(), <span class="selector-tag">a</span>.values())))</span><br><span class="line">&#123;<span class="string">'addr'</span>: <span class="string">'CHINA'</span>, <span class="string">'name'</span>: <span class="string">'SAMY'</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = dict(name=<span class="string">'samy'</span>,addr=<span class="string">'china'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.keys()</span><br><span class="line">[<span class="string">'addr'</span>, <span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dict(zip(map(lambda x: x.upper(), <span class="selector-tag">a</span>.keys()), map(lambda x: x.upper(), <span class="selector-tag">a</span>.values())))</span><br><span class="line">&#123;<span class="string">'ADDR'</span>: <span class="string">'CHINA'</span>, <span class="string">'NAME'</span>: <span class="string">'SAMY'</span>&#125;</span><br><span class="line"></span><br><span class="line">﻿﻿&gt;&gt;&gt; map(lambda (k,v): (k+<span class="string">"1"</span>,v+<span class="string">"1"</span>),<span class="selector-tag">a</span>.items())</span><br><span class="line">[(<span class="string">'name1'</span>, <span class="string">'samy1'</span>), (<span class="string">'addr1'</span>, <span class="string">'china1'</span>)]</span><br><span class="line">&gt;&gt;&gt; dict(map(lambda (k,v): (k+<span class="string">"1"</span>,v+<span class="string">"1"</span>),<span class="selector-tag">a</span>.items()))</span><br><span class="line">&#123;<span class="string">'addr1'</span>: <span class="string">'china1'</span>, <span class="string">'name1'</span>: <span class="string">'samy1'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = dict(&lt;span class=&quot;attribute&quot;&gt;addr&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&#39;china&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&#39;samy&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;map 函数上述字典返回的是一个 list，那如何返回字典呢？&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; map(lambda &lt;span class=&quot;symbol&quot;&gt;x:&lt;/span&gt; x.upper(), a.values())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;CHINA&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;SAMY&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回字典的方法：&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="函数" scheme="http://codebooks.dongfei.xin/categories/Python/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python itertools模块中排列组合函数</title>
    <link href="http://codebooks.dongfei.xin/2018-08-11/Python-itertools%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"/>
    <id>http://codebooks.dongfei.xin/2018-08-11/Python-itertools模块中排列组合函数/</id>
    <published>2018-08-11T04:18:16.000Z</published>
    <updated>2018-08-11T04:25:35.453Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">字段类型</th><th style="text-align:center">字段含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>product</code></td><td style="text-align:center">笛卡尔积</td><td style="text-align:center">有放回抽样排列</td></tr><tr><td style="text-align:center"><code>permutations</code></td><td style="text-align:center">排列</td><td style="text-align:center">不放回抽样排列</td></tr><tr><td style="text-align:center"><code>combinations</code></td><td style="text-align:center">组合、没有重复</td><td style="text-align:center">不放回抽样组合</td></tr><tr><td style="text-align:center"><code>combinations_with_replacement</code></td><td style="text-align:center">组合、有重复</td><td style="text-align:center">有放回抽样组合</td></tr></tbody></table><p>详细的参见<a href="https://docs.python.org/2/library/itertools.html" target="_blank" rel="noopener">官网</a></p><a id="more"></a><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">import</span> <span class="selector-tag">itertools</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.product</span>(<span class="string">'ABCD'</span>, repeat = <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>) (<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'A'</span>) (<span class="string">'B'</span>, <span class="string">'B'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'A'</span>) (<span class="string">'C'</span>, <span class="string">'B'</span>) (<span class="string">'C'</span>, <span class="string">'C'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>) (<span class="string">'D'</span>, <span class="string">'A'</span>) (<span class="string">'D'</span>, <span class="string">'B'</span>) (<span class="string">'D'</span>, <span class="string">'C'</span>) (<span class="string">'D'</span>, <span class="string">'D'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.permutations</span>(<span class="string">'ABCD'</span>, <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'A'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'A'</span>) (<span class="string">'C'</span>, <span class="string">'B'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>) (<span class="string">'D'</span>, <span class="string">'A'</span>) (<span class="string">'D'</span>, <span class="string">'B'</span>) (<span class="string">'D'</span>, <span class="string">'C'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.combinations</span>(<span class="string">'ABCD'</span>, <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">itertools</span><span class="selector-class">.combinations_with_replacement</span>(<span class="string">'ABCD'</span>, <span class="number">2</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(i)</span><br><span class="line">... </span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>) (<span class="string">'A'</span>, <span class="string">'B'</span>) (<span class="string">'A'</span>, <span class="string">'C'</span>) (<span class="string">'A'</span>, <span class="string">'D'</span>) (<span class="string">'B'</span>, <span class="string">'B'</span>) (<span class="string">'B'</span>, <span class="string">'C'</span>) (<span class="string">'B'</span>, <span class="string">'D'</span>) (<span class="string">'C'</span>, <span class="string">'C'</span>) (<span class="string">'C'</span>, <span class="string">'D'</span>) (<span class="string">'D'</span>, <span class="string">'D'</span>)</span><br></pre></td></tr></table></figure><p>还有就是， <code>combinations</code> 和 <code>permutations</code> 返回的是对象地址，原因是在 <code>Python3</code> 里面，返回值已经不再是 <code>list</code> ，而是 <code>iterators</code> （迭代器）， 所以想要使用，只用将 <code>iterator</code> 转换成 <code>list</code> 即可， 还有其他一些函数返回的也是一个对象，需要 <code>list</code> 转换，比如 <code>list(map())</code> 等 。</p>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字段名称&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字段类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字段含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;笛卡尔积&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有放回抽样排列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;permutations&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;排列&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不放回抽样排列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;combinations&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;组合、没有重复&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不放回抽样组合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;combinations_with_replacement&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;组合、有重复&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有放回抽样组合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;详细的参见&lt;a href=&quot;https://docs.python.org/2/library/itertools.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="内置函数" scheme="http://codebooks.dongfei.xin/categories/Python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>4.01 手动遍历迭代器</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/4-01-%E6%89%8B%E5%8A%A8%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/4-01-手动遍历迭代器/</id>
    <published>2018-06-08T06:58:43.000Z</published>
    <updated>2018-06-08T07:13:15.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第四章：迭代器与生成器"><a href="#第四章：迭代器与生成器" class="headerlink" title="第四章：迭代器与生成器"></a>第四章：迭代器与生成器</h3><p>迭代是 <code>Python</code> 最强大的功能之一。初看起来，你可能会简单的认为迭代只不过是处理序列中元素的一种方法。然而，绝非仅仅就是如此，还有很多你可能不知道的，比如创建你自己的迭代器对象，在 <code>itertools</code> 模块中使用有用的迭代模式，构造生成器函数等等。这一章目的就是向你展示跟迭代有关的各种常见问题。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想遍历一个可迭代对象中的所有元素，但是却不想使用 <code>for</code> 循环。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了手动的遍历可迭代对象，使用 <code>next()</code> 函数并在代码中捕获 <code>StopIteration</code> 异常。 比如，下面的例子手动读取一个文件中的所有行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manual_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                line = next(f)</span><br><span class="line">                print(line, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>通常来讲， <code>StopIteration</code> 用来指示迭代的结尾。然而，如果你手动使用上面演示的 <code>next()</code> 函数的话，你还可以通过返回一个指定值来标记结尾，比如 <code>None</code> 。</p><p>下面是示例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with <span class="keyword">open</span>(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="built_in">line</span> = <span class="keyword">next</span>(<span class="keyword">f</span>, None)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">line</span> <span class="keyword">is</span> None:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span>(<span class="built_in">line</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>大多数情况下，我们会使用 <code>for</code> 循环语句用来遍历一个可迭代对象。但是，偶尔也需要对迭代做更加精确的控制，这时候了解底层迭代机制就显得尤为重要了。</p><p>下面的交互示例向我们演示了迭代期间所发生的基本细节：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Get the iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; it = iter(items) <span class="comment"># Invokes items.__iter__()</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run the iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it) <span class="comment"># Invokes it.__next__()</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(it)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>本章接下来几小节会更深入的讲解迭代相关技术，前提是你先要理解基本的迭代协议机制。所以确保你已经把这章的内容牢牢记在心中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第四章：迭代器与生成器&quot;&gt;&lt;a href=&quot;#第四章：迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;第四章：迭代器与生成器&quot;&gt;&lt;/a&gt;第四章：迭代器与生成器&lt;/h3&gt;&lt;p&gt;迭代是 &lt;code&gt;Python&lt;/code&gt; 最强大的功能之一。初看起来，你可能会简单的认为迭代只不过是处理序列中元素的一种方法。然而，绝非仅仅就是如此，还有很多你可能不知道的，比如创建你自己的迭代器对象，在 &lt;code&gt;itertools&lt;/code&gt; 模块中使用有用的迭代模式，构造生成器函数等等。这一章目的就是向你展示跟迭代有关的各种常见问题。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想遍历一个可迭代对象中的所有元素，但是却不想使用 &lt;code&gt;for&lt;/code&gt; 循环。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="迭代器与生成器" scheme="http://codebooks.dongfei.xin/categories/Python/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>4.02 代理迭代</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/4-02-%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/4-02-代理迭代/</id>
    <published>2018-06-08T06:58:41.000Z</published>
    <updated>2018-06-08T07:10:49.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。你想直接在你的这个新容器对象上执行迭代操作。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>实际上你只需要定义一个 <code>__iter__()</code> 方法，将迭代操作代理到容器内部的对象上去。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._value = value</span><br><span class="line">        <span class="keyword">self</span>._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(<span class="keyword">self</span>._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> iter(<span class="keyword">self</span>._children)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = Node(<span class="number">0</span>)</span><br><span class="line">    child1 = Node(<span class="number">1</span>)</span><br><span class="line">    child2 = Node(<span class="number">2</span>)</span><br><span class="line">    root.add_child(child1)</span><br><span class="line">    root.add_child(child2)</span><br><span class="line">    <span class="comment"># Outputs Node(1), Node(2)</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="symbol">root:</span></span><br><span class="line">        print(ch)</span><br></pre></td></tr></table></figure><p>在上面代码中， <code>__iter__()</code> 方法只是简单的将迭代请求传递给内部的 <code>_children</code> 属性。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>Python</code> 的迭代器协议需要 <code>__iter__()</code> 方法返回一个实现了 <code>__next__()</code> 方法的迭代器对象。如果你只是迭代遍历其他容器的内容，你无须担心底层是怎样实现的。你所要做的只是传递迭代请求既可。</p><p>这里的 <code>iter()</code> 函数的使用简化了代码，<code>iter(s)</code> 只是简单的通过调用 <code>s.__iter__()</code> 方法来返回对应的迭代器对象，就跟 <code>len(s)</code> 会调用 <code>s.__len__()</code> 原理是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。你想直接在你的这个新容器对象上执行迭代操作。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="迭代器与生成器" scheme="http://codebooks.dongfei.xin/categories/Python/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>4.03 使用生成器创建新的迭代模式</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/4-03-%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/4-03-使用生成器创建新的迭代模式/</id>
    <published>2018-06-08T06:58:39.000Z</published>
    <updated>2018-06-08T07:08:54.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想实现一个自定义迭代模式，跟普通的内置函数比如 <code>range()</code> 、 <code>reversed()</code>不一样。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果你想实现一种新的迭代模式，使用一个生成器函数来定义它。下面是一个生产某个范围内浮点数的生成器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def frange(<span class="keyword">start</span>, <span class="keyword">stop</span>, <span class="keyword">increment</span>):</span><br><span class="line">    x = <span class="keyword">start</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; <span class="keyword">stop</span>:</span><br><span class="line">        yield x</span><br><span class="line">        x += <span class="keyword">increment</span></span><br></pre></td></tr></table></figure><p>为了使用这个函数，你可以用 <code>for</code> 循环迭代它或者使用其他接受一个可迭代对象的函数(比如 <code>sum()</code> 、 <code>list()</code> 等)。示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">for</span> <span class="selector-tag">n</span> <span class="selector-tag">in</span> <span class="selector-tag">frange</span>(0, 4, 0<span class="selector-class">.5</span>):</span><br><span class="line">...     <span class="selector-tag">print</span>(<span class="selector-tag">n</span>)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">0<span class="selector-class">.5</span></span><br><span class="line">1<span class="selector-class">.0</span></span><br><span class="line">1<span class="selector-class">.5</span></span><br><span class="line">2<span class="selector-class">.0</span></span><br><span class="line">2<span class="selector-class">.5</span></span><br><span class="line">3<span class="selector-class">.0</span></span><br><span class="line">3<span class="selector-class">.5</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">list</span>(<span class="selector-tag">frange</span>(0, 1, 0<span class="selector-class">.125</span>))</span><br><span class="line"><span class="selector-attr">[0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>一个函数中需要有一个 <code>yield</code> 语句即可将其转换为一个生成器。跟普通函数不同的是，生成器只能用于迭代操作。下面是一个实验，向你展示这样的函数底层工作机制：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span></span><span class="symbol">:</span></span><br><span class="line">...     print(<span class="string">'Starting to count from'</span>, n)</span><br><span class="line">...     <span class="keyword">while</span> n &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">yield</span> n</span><br><span class="line">...         n -= <span class="number">1</span></span><br><span class="line">...     print(<span class="string">'Done!'</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Create the generator, notice no output appears</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = countdown(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c</span><br><span class="line">&lt;generator object countdown at <span class="number">0x1006a0af0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to first yield and emit a value</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line">Starting to count from <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to the next yield</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to next yield</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Run to next yield (iteration stops)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; next(c)</span><br><span class="line">Done!</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>一个生成器函数主要特征是它只会回应在迭代中使用到的 <code>next</code> 操作。一旦生成器函数返回退出，迭代终止。我们在迭代中通常使用的 <code>for</code> 语句会自动处理这些细节，所以你无需担心。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想实现一个自定义迭代模式，跟普通的内置函数比如 &lt;code&gt;range()&lt;/code&gt; 、 &lt;code&gt;reversed()&lt;/code&gt;不一样。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="迭代器与生成器" scheme="http://codebooks.dongfei.xin/categories/Python/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>4.04 实现迭代器协议</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/4-04-%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/4-04-实现迭代器协议/</id>
    <published>2018-06-08T06:58:37.000Z</published>
    <updated>2018-06-08T07:06:29.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想构建一个能支持迭代操作的自定义对象，并希望找到一个能实现迭代协议的简单方法。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>目前为止，在一个对象上实现迭代最简单的方式是使用一个生成器函数。 在<code>4.2 小节</code>中，使用 Node 类来表示树形数据结构。你可能想实现一个以深度优先方式遍历树形节点的生成器。 下面是代码示例：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">:</span></span><br><span class="line"><span class="title">    def</span> __init__(self, value):</span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return '<span class="keyword">Node</span><span class="title">(&#123;!r</span>&#125;)'.format(self._value)</span><br><span class="line"></span><br><span class="line">    def add_child(self, <span class="keyword">node</span><span class="title">):</span></span><br><span class="line"><span class="title">        self</span>._children.append(<span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    def</span> __iter__(self):</span><br><span class="line">        return iter(self._children)</span><br><span class="line"></span><br><span class="line">    def depth_first(self):</span><br><span class="line">        yield self</span><br><span class="line">        for c <span class="keyword">in</span> self:</span><br><span class="line">            yield from c.depth_first()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    root = <span class="keyword">Node</span><span class="title">(0</span>)</span><br><span class="line">    child1 = <span class="keyword">Node</span><span class="title">(1</span>)</span><br><span class="line">    child2 = <span class="keyword">Node</span><span class="title">(2</span>)</span><br><span class="line">    root.add_child(child1)</span><br><span class="line">    root.add_child(child2)</span><br><span class="line">    child1.add_child(<span class="keyword">Node</span><span class="title">(3</span>))</span><br><span class="line">    child1.add_child(<span class="keyword">Node</span><span class="title">(4</span>))</span><br><span class="line">    child2.add_child(<span class="keyword">Node</span><span class="title">(5</span>))</span><br><span class="line"></span><br><span class="line">    for ch <span class="keyword">in</span> root.depth_first():</span><br><span class="line">        print(ch)</span><br><span class="line">    <span class="comment"># Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>depth_first()</code> 方法简单直观。它首先返回自己本身并迭代每一个子节点并通过调用子节点的 <code>depth_first()</code> 方法(使用 <code>yield from</code> 语句)返回对应元素。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>Python</code> 的迭代协议要求一个 <code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。 但是，实现这些通常会比较繁琐。下面我们演示下这种方式，如何使用一个关联迭代器类重新实现 <code>depth_first()</code> 方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._value = value</span><br><span class="line">        <span class="keyword">self</span>._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(<span class="keyword">self</span>._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> iter(<span class="keyword">self</span>._children)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth_first</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> DepthFirstIterator(<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstIterator</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    Depth-first traversal</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, start_node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._node = start_node</span><br><span class="line">        <span class="keyword">self</span>._children_iter = None</span><br><span class="line">        <span class="keyword">self</span>._child_iter = None</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># Return myself if just started; create an iterator for children</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>._children_iter is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">self</span>._children_iter = iter(<span class="keyword">self</span>._node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>._node</span><br><span class="line">        <span class="comment"># If processing a child, return its next item</span></span><br><span class="line">        elif <span class="keyword">self</span>.<span class="symbol">_child_iter:</span></span><br><span class="line">            <span class="symbol">try:</span></span><br><span class="line">                nextchild = <span class="keyword">next</span>(<span class="keyword">self</span>._child_iter)</span><br><span class="line">                <span class="keyword">return</span> nextchild</span><br><span class="line">            except <span class="symbol">StopIteration:</span></span><br><span class="line">                <span class="keyword">self</span>._child_iter = None</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">next</span>(<span class="keyword">self</span>)</span><br><span class="line">        <span class="comment"># Advance to the next child and start its iteration</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="keyword">self</span>._child_iter = <span class="keyword">next</span>(<span class="keyword">self</span>._children_iter).depth_first()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">next</span>(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p><code>DepthFirstIterator</code> 类和上面使用生成器的版本工作原理类似，但是它写起来很繁琐，因为迭代器必须在迭代处理过程中维护大量的状态信息。坦白来讲，没人愿意写这么晦涩的代码。将你的迭代器定义为一个生成器后一切迎刃而解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想构建一个能支持迭代操作的自定义对象，并希望找到一个能实现迭代协议的简单方法。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="迭代器与生成器" scheme="http://codebooks.dongfei.xin/categories/Python/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>4.05 反向迭代</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/4-05-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/4-05-反向迭代/</id>
    <published>2018-06-08T06:58:35.000Z</published>
    <updated>2018-06-08T07:01:56.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想反方向迭代一个序列</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用内置的 <code>reversed()</code> 函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> reversed(a):</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>反向迭代仅仅当对象的大小可预先确定或者对象实现了 <code>__reversed__()</code>的特殊方法时才能生效。如果两者都不符合，那你必须先将对象转换为一个列表才行，比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Print a file backwards</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">'somefile'</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> reversed(list(f)):</span><br><span class="line">    print(<span class="built_in">line</span>, <span class="keyword">end</span>=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>要注意的是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>很多程序员并不知道可以通过在自定义类上实现<code>__reversed__()</code>方法来实现反向迭代。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, start)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.start = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        n = <span class="keyword">self</span>.start</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reverse iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &lt;= <span class="keyword">self</span>.<span class="symbol">start:</span></span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> reversed(Countdown(<span class="number">30</span>))<span class="symbol">:</span></span><br><span class="line">    print(rr)</span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> Countdown(<span class="number">30</span>)<span class="symbol">:</span></span><br><span class="line">    print(rr)</span><br></pre></td></tr></table></figure><p>定义一个反向迭代器可以使得代码非常的高效，因为它不再需要将数据填充到一个列表中然后再去反向迭代这个列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想反方向迭代一个序列&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="迭代器与生成器" scheme="http://codebooks.dongfei.xin/categories/Python/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>5.01 读写文本数据</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/5-01-%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/5-01-读写文本数据/</id>
    <published>2018-06-08T06:04:59.000Z</published>
    <updated>2018-06-08T06:56:50.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第五章：文件与-IO"><a href="#第五章：文件与-IO" class="headerlink" title="第五章：文件与 IO"></a>第五章：文件与 IO</h3><p>所有程序都要处理输入和输出。这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。对文件名和目录的操作也会涉及到。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你需要读写各种不同编码的文本数据，比如 <code>ASCII</code> ，<code>UTF-8</code> 或 <code>UTF-16</code> 编码等。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用带有 <code>rt</code> 模式的 <code>open()</code> 函数读取文本文件。如下所示：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read the entire file as a single string</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.<span class="built_in">read</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the lines of the file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment"># process line</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>类似的，为了写入一个文本文件，使用带有 <code>wt</code> 模式的 <code>open()</code> 函数，如果之前文件内容存在则清除并覆盖掉。如下所示：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Write chunks of text data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.<span class="built_in">write</span>(text1)</span><br><span class="line">    f.<span class="built_in">write</span>(text2)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redirected print statement</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(line1, <span class="built_in">file</span>=f)</span><br><span class="line">    print(line2, <span class="built_in">file</span>=f)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果是在已存在文件中添加内容，使用模式为 <code>at</code> 的 <code>open()</code> 函数。</p><p>文件的读写操作默认使用系统编码，可以通过调用 <code>sys.getdefaultencoding()</code>来得到。在大多数机器上面都是 <code>utf-8</code> 编码。如果你已经知道你要读写的文本是其他编码方式，那么可以通过传递一个可选的 <code>encoding</code> 参数给 <code>open()</code> 函数。如下所示：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'latin-1'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>Python</code> 支持非常多的文本编码。几个常见的编码是 <code>ascii</code> 、 <code>latin-1</code> 、 <code>utf-8</code> 和 <code>utf-16</code> 。在 <code>web</code> 应用程序中通常都使用的是 <code>UTF-8</code> 。<code>ascii</code> 对应从 <code>U+0000</code> 到 <code>U+007F</code> 范围内的 <code>7</code> 位字符。<code>latin-1</code> 是字节 <code>0-255</code> 到 <code>U+0000</code> 至 <code>U+00FF</code> 范围内 <code>Unicode</code> 字符的直接映射。当读取一个未知编码的文本时使用 <code>latin-1</code>编码永远不会产生解码错误。使用 <code>latin-1</code> 编码读取一个文件的时候也许不能产生完全正确的文本解码数据， 但是它也能从中提取出足够多的有用数据。同时，如果你之后将数据回写回去，原先的数据还是会保留的。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>读写文本文件一般来讲是比较简单的。但是也几点是需要注意的。首先，在例子程序中的 <code>with</code> 语句给被使用到的文件创建了一个上下文环境， 但 <code>with</code> 控制块结束时，文件会自动关闭。你也可以不使用 <code>with</code> 语句，但是这时候你就必须记得手动关闭文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>)</span><br><span class="line">data = f.<span class="built_in">read</span>()</span><br><span class="line">f.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>另外一个问题是关于换行符的识别问题，在 <code>Unix</code> 和 <code>Windows</code> 中是不一样的(分别是 <code>\n</code> 和 <code>\r\n</code> )。 默认情况下，<code>Python</code> 会以统一模式处理换行符。这种模式下，在读取文本的时候， <code>Python</code> 可以识别所有的普通换行符并将其转换为单个 <code>\n</code> 字符。类似的，在输出时会将换行符 <code>\n</code>转换为系统默认的换行符。 如果你不希望这种默认的处理方式，可以给 <code>open()</code> 函数传入参数 <code>newline=&#39;&#39;</code> ，就像下面这样：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Read <span class="keyword">with</span> disabled newline translation</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>为了说明两者之间的差异，下面我在 <code>Unix</code> 机器上面读取一个 <code>Windows</code> 上面的文本文件，里面的内容是 <code>hello world!\r\n</code> ：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Newline translation enabled (the default)</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f = open(<span class="string">'hello.txt'</span>, <span class="string">'rt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f.read()</span><br><span class="line"><span class="string">'hello world!\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Newline translation disabled</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g = open(<span class="string">'hello.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g.read()</span><br><span class="line"><span class="string">'hello world!\r\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>最后一个问题就是文本文件中可能出现的编码错误。但你读取或者写入一个文本文件时，你可能会遇到一个编码或者解码错误。比如：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = <span class="keyword">open</span>(<span class="symbol">'sample</span>.txt', <span class="symbol">'rt</span>', encoding=<span class="symbol">'ascii</span>')</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="literal">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.3/encodings/ascii.py"</span>, <span class="literal">line</span> <span class="number">26</span>, <span class="keyword">in</span> decode</span><br><span class="line">        <span class="keyword">return</span> codecs.ascii_decode(input, self.errors)[<span class="number">0</span>]</span><br><span class="line">UnicodeDecodeError: <span class="symbol">'ascii</span>' codec can<span class="symbol">'t</span> decode byte <span class="number">0</span>xc3 <span class="keyword">in</span> position</span><br><span class="line"><span class="number">12</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">128</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果出现这个错误，通常表示你读取文本时指定的编码不正确。你最好仔细阅读说明并确认你的文件编码是正确的（比如使用 <code>UTF-8</code> 而不是 <code>Latin-1</code> 编码或其他）。如果编码错误还是存在的话，你可以给 <code>open()</code> 函数传递一个可选的 <code>errors</code> 参数来处理这些错误。下面是一些处理常见错误的方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Replace bad chars with Unicode U+fffd replacement char</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f = open(<span class="string">'sample.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'ascii'</span>, errors=<span class="string">'replace'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f.read()</span><br><span class="line"><span class="string">'Spicy Jalape?o!'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Ignore bad chars entirely</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g = open(<span class="string">'sample.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'ascii'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; g.read()</span><br><span class="line"><span class="string">'Spicy Jalapeo!'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你经常使用 <code>errors</code> 参数来处理编码错误，可能会让你的生活变得很糟糕。对于文本处理的首要原则是确保你总是使用的是正确编码。当模棱两可的时候，就使用默认的设置（通常都是 <code>UTF-8</code> ）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第五章：文件与-IO&quot;&gt;&lt;a href=&quot;#第五章：文件与-IO&quot; class=&quot;headerlink&quot; title=&quot;第五章：文件与 IO&quot;&gt;&lt;/a&gt;第五章：文件与 IO&lt;/h3&gt;&lt;p&gt;所有程序都要处理输入和输出。这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。对文件名和目录的操作也会涉及到。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你需要读写各种不同编码的文本数据，比如 &lt;code&gt;ASCII&lt;/code&gt; ，&lt;code&gt;UTF-8&lt;/code&gt; 或 &lt;code&gt;UTF-16&lt;/code&gt; 编码等。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="文件与 IO" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%96%87%E4%BB%B6%E4%B8%8E-IO/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>5.02 打印输出至文件中</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/5-02-%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E8%87%B3%E6%96%87%E4%BB%B6%E4%B8%AD/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/5-02-打印输出至文件中/</id>
    <published>2018-06-08T06:04:57.000Z</published>
    <updated>2018-06-08T06:49:06.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想将 <code>print()</code> 函数的输出重定向到一个文件中去。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 <code>print()</code> 函数中指定 <code>file</code> 关键字参数，像下面这样：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'d:/work/test.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'Hello World!'</span>, <span class="built_in">file</span>=f)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>关于输出重定向到文件中就这些了。但是有一点要注意的就是文件必须是以文本模式打开。 如果文件是二进制模式的话，打印就会出错。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想将 &lt;code&gt;print()&lt;/code&gt; 函数的输出重定向到一个文件中去。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="文件与 IO" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%96%87%E4%BB%B6%E4%B8%8E-IO/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>5.03 使用其他分隔符或行终止符打印</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/5-03-%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%88%86%E9%9A%94%E7%AC%A6%E6%88%96%E8%A1%8C%E7%BB%88%E6%AD%A2%E7%AC%A6%E6%89%93%E5%8D%B0/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/5-03-使用其他分隔符或行终止符打印/</id>
    <published>2018-06-08T06:04:55.000Z</published>
    <updated>2018-06-08T06:46:13.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想使用 <code>print()</code> 函数输出数据，但是想改变默认的分隔符或者行尾符。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以使用在 <code>print()</code> 函数中使用 <code>sep</code> 和 <code>end</code> 关键字参数，以你想要的方式输出。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'ACME'</span>, 50, 91.5)</span></span><br><span class="line">ACME 50 91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'ACME'</span>, 50, 91.5, sep=<span class="string">','</span>)</span></span><br><span class="line">ACME,50,91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'ACME'</span>, 50, 91.5, sep=<span class="string">','</span>, end=<span class="string">'!!\n'</span>)</span></span><br><span class="line">ACME,50,91.5!!</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>end</code> 参数也可以在输出中禁止换行。比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line"><span class="built_in">..</span>.     <span class="builtin-name">print</span>(i)</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line"><span class="built_in">..</span>.     <span class="builtin-name">print</span>(i, <span class="attribute">end</span>=<span class="string">' '</span>)</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">0 1 2 3 4 &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>当你想使用非空格分隔符来输出数据的时候，给 <code>print()</code> 函数传递一个 <code>sep</code> 参数是最简单的方案。有时候你会看到一些程序员会使用 <code>str.join()</code> 来完成同样的事情。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">','</span>.join((<span class="string">'ACME'</span>,<span class="string">'50'</span>,<span class="string">'91.5'</span>)))</span></span><br><span class="line">ACME,50,91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><code>str.join()</code> 的问题在于它仅仅适用于字符串。这意味着你通常需要执行另外一些转换才能让它正常工作。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; row = (<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">','</span>.join(row))</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> sequence item <span class="number">1</span>: expected str instance, int found</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">','</span>.join(str(x) for x in row))</span><br><span class="line">ACME,<span class="number">50</span>,<span class="number">91.5</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>你当然可以不用那么麻烦，只需要像下面这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(*row, sep=<span class="string">','</span>)</span></span><br><span class="line">ACME,50,91.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想使用 &lt;code&gt;print()&lt;/code&gt; 函数输出数据，但是想改变默认的分隔符或者行尾符。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="文件与 IO" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%96%87%E4%BB%B6%E4%B8%8E-IO/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>5.04 读写字节数据问题</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/5-04-%E8%AF%BB%E5%86%99%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/5-04-读写字节数据问题/</id>
    <published>2018-06-08T06:04:53.000Z</published>
    <updated>2018-06-08T06:14:01.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想读写二进制文件，比如图片，声音文件等等。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用模式为 <code>rb</code> 或 <code>wb</code> 的 <code>open()</code> 函数来读取或写入二进制数据。比如：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Read</span> the entire <span class="keyword">file</span> <span class="keyword">as</span> a single byte <span class="keyword">string</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.<span class="keyword">read</span>()</span><br><span class="line"></span><br><span class="line"># <span class="keyword">Write</span> binary data <span class="keyword">to</span> a <span class="keyword">file</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.<span class="keyword">write</span>(b<span class="string">'Hello World'</span>)</span><br></pre></td></tr></table></figure><p>在读取二进制数据时，需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串。类似的，在写入的时候，必须保证参数是以字节形式对外暴露数据的对象（比如字节字符串，字节数组对象等）。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>在读取二进制数据的时候，字节字符串和文本字符串的语义差异可能会导致一个潜在的陷阱。 特别需要注意的是，索引和迭代动作返回的是字节的值而不是字节字符串。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Text string</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t = <span class="string">'Hello World'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t[0]</span></span><br><span class="line">'H'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> c <span class="keyword">in</span> t:</span></span><br><span class="line">...     print(c)</span><br><span class="line">...</span><br><span class="line">H</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># Byte string</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = b<span class="string">'Hello World'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b[0]</span></span><br><span class="line">72</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> c <span class="keyword">in</span> b:</span></span><br><span class="line">...     print(c)</span><br><span class="line">...</span><br><span class="line">72</span><br><span class="line">101</span><br><span class="line">108</span><br><span class="line">108</span><br><span class="line">111</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想从二进制模式的文件中读取或写入文本数据，必须确保要进行解码和编码操作。比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.<span class="built_in">read</span>(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">text</span> = data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">text</span> = <span class="string">'Hello World'</span></span><br><span class="line">    f.<span class="built_in">write</span>(<span class="keyword">text</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>二进制 <code>I/O</code> 还有一个鲜为人知的特性就是数组和 <code>C</code> 结构体类型能直接被写入，而不需要中间转换为自己对象。比如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import array</span><br><span class="line">nums = array.array('i', [1, 2, 3, 4])</span><br><span class="line">with open('data.bin','wb') as f:</span><br><span class="line">    f.write(nums)</span><br></pre></td></tr></table></figure><p>这个适用于任何实现了被称之为 缓冲接口的对象，这种对象会直接暴露其底层的内存缓冲区给能处理它的操作。二进制数据的写入就是这类操作之一。</p><p>很多对象还允许通过使用文件对象的 <code>readinto()</code> 方法直接读取二进制数据到其底层的内存中去。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import array</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = array.array(<span class="string">'i'</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; with open(<span class="string">'data.bin'</span>, <span class="string">'rb'</span>) as <span class="symbol">f:</span></span><br><span class="line">...     f.readinto(a)</span><br><span class="line">...</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line">array(<span class="string">'i'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>但是使用这种技术的时候需要格外小心，因为它通常具有平台相关性，并且可能会依赖字长和字节顺序（高位优先和低位优先）。可以查看 <code>5.9小节</code> 中另外一个读取二进制数据到可修改缓冲区的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想读写二进制文件，比如图片，声音文件等等。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="文件与 IO" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%96%87%E4%BB%B6%E4%B8%8E-IO/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>5.05 文件不存在才能写入</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/5-05-%E6%96%87%E4%BB%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%89%8D%E8%83%BD%E5%86%99%E5%85%A5/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/5-05-文件不存在才能写入/</id>
    <published>2018-06-08T06:04:51.000Z</published>
    <updated>2018-06-08T06:11:54.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想向一个文件中写入数据，但是前提必须是这个文件在文件系统上不存在。也就是不允许覆盖已存在的文件内容。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以在 <code>open()</code> 函数中使用x模式来代替w模式的方法来解决这个问题。比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">...     f.<span class="built_in">write</span>(<span class="string">'Hello\n'</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'somefile'</span>, <span class="string">'xt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">...     f.<span class="built_in">write</span>(<span class="string">'Hello\n'</span>)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">FileExistsError: [Errno <span class="number">17</span>] File exists: <span class="string">'somefile'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果文件是二进制的，使用 <code>xb</code> 来代替 <code>xt</code> </p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>这一小节演示了在写文件时通常会遇到的一个问题的完美解决方案（不小心覆盖一个已存在的文件）。 一个替代方案是先测试这个文件是否存在，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'somefile'</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">with</span> open(<span class="string">'somefile'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>        f.write(<span class="string">'Hello\n'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'File already exists!'</span>)</span><br><span class="line">...</span><br><span class="line">File already exists!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>显而易见，使用x文件模式更加简单。要注意的是 <code>x</code> 模式是一个 <code>Python3</code> 对 <code>open()</code> 函数特有的扩展。在 <code>Python</code> 的旧版本或者是 <code>Python</code> 实现的底层 <code>C</code> 函数库中都是没有这个模式的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想向一个文件中写入数据，但是前提必须是这个文件在文件系统上不存在。也就是不允许覆盖已存在的文件内容。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="文件与 IO" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%96%87%E4%BB%B6%E4%B8%8E-IO/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>6.01 读写 CSV 数据</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/6-01-%E8%AF%BB%E5%86%99-CSV-%E6%95%B0%E6%8D%AE/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/6-01-读写-CSV-数据/</id>
    <published>2018-06-08T05:35:44.000Z</published>
    <updated>2018-06-08T05:58:35.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第六章：数据编码和处理"><a href="#第六章：数据编码和处理" class="headerlink" title="第六章：数据编码和处理"></a>第六章：数据编码和处理</h3><p>这一章主要讨论使用 <code>Python</code> 处理各种不同方式编码的数据，比如 <code>CSV</code> 文件， <code>JSON</code> ， <code>XML</code> 和二进制包装记录。和数据结构那一章不同的是，这章不会讨论特殊的算法问题，而是关注于怎样获取和存储这些格式的数据。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想读写一个 <code>CSV</code> 格式的文件。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于大多数的 <code>CSV</code> 格式的数据读写问题，都可以使用 <code>csv</code> 库。例如：假设你在一个名叫 <code>stocks.csv</code> 文件中有一些股票市场数据，就像这样：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol,Price,Date,Time,Change,Volume</span><br><span class="line"><span class="string">"AA"</span>,<span class="number">39.48</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.18</span>,<span class="number">181800</span></span><br><span class="line"><span class="string">"AIG"</span>,<span class="number">71.38</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.15</span>,<span class="number">195500</span></span><br><span class="line"><span class="string">"AXP"</span>,<span class="number">62.58</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.46</span>,<span class="number">935000</span></span><br><span class="line"><span class="string">"BA"</span>,<span class="number">98.31</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,+<span class="number">0.12</span>,<span class="number">104800</span></span><br><span class="line"><span class="string">"C"</span>,<span class="number">53.08</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.25</span>,<span class="number">360900</span></span><br><span class="line"><span class="string">"CAT"</span>,<span class="number">78.29</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.23</span>,<span class="number">225400</span></span><br></pre></td></tr></table></figure><p>下面向你展示如何将这些数据读取为一个元组的序列：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    for row <span class="keyword">in</span> f_csv:</span><br><span class="line">        # Process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在上面的代码中， <code>row</code> 会是一个列表。因此，为了访问某个字段，你需要使用下标，如 <code>row[0]</code>访问 <code>Symbol，row[4]</code> 访问 <code>Change</code> 。</p><p>由于这种下标访问通常会引起混淆，你可以考虑使用命名元组。例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stock.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headings = next(f_csv)</span><br><span class="line">    Row = namedtuple(<span class="string">'Row'</span>, headings)</span><br><span class="line">    for r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        # Process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>它允许你使用列名如 <code>row.Symbol</code> 和 <code>row.Change</code> 代替下标访问。需要注意的是这个只有在列名是合法的 <code>Python</code> 标识符的时候才生效。如果不是的话，你可能需要修改下原始的列名（如将非标识符字符替换成下划线之类的）。</p><p>另外一个选择就是将数据读取到一个字典序列中去。可以这样做：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictReader(f)</span><br><span class="line">    for row <span class="keyword">in</span> f_csv:</span><br><span class="line">        # process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在这个版本中，你可以使用列名去访问每一行的数据了。比如，<code>row[&#39;Symbol&#39;]</code> 或者 <code>row[&#39;Change&#39;]</code></p><p>为了写入 <code>CSV</code> 数据，你仍然可以使用 <code>csv</code> 模块，不过这时候先创建一个 <code>writer</code> 对象。例如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">headers = ['Symbol','Price','Date','Time','Change','Volume']</span><br><span class="line">rows = [('AA', <span class="number">39.48</span>, '6/11/<span class="number">2007</span>', '9:36am', -<span class="number">0.18</span>, <span class="number">181800</span>),</span><br><span class="line">         ('AIG', <span class="number">71.38</span>, '6/11/<span class="number">2007</span>', '9:36am', -<span class="number">0.15</span>, <span class="number">195500</span>),</span><br><span class="line">         ('AXP', <span class="number">62.58</span>, '6/11/<span class="number">2007</span>', '9:36am', -<span class="number">0.46</span>, <span class="number">935000</span>),</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line">with open('stocks.csv','w') as f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure><p>如果你有一个字典序列的数据，可以像这样做：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">'Symbol'</span>, <span class="string">'Price'</span>, <span class="string">'Date'</span>, <span class="string">'Time'</span>, <span class="string">'Change'</span>, <span class="string">'Volume'</span>]</span><br><span class="line">rows = [&#123;<span class="string">'Symbol'</span>:<span class="string">'AA'</span>, <span class="string">'Price'</span>:<span class="number">39.48</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:-<span class="number">0.18</span>, <span class="string">'Volume'</span>:<span class="number">181800</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AIG'</span>, <span class="string">'Price'</span>: <span class="number">71.38</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:-<span class="number">0.15</span>, <span class="string">'Volume'</span>: <span class="number">195500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AXP'</span>, <span class="string">'Price'</span>: <span class="number">62.58</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:-<span class="number">0.46</span>, <span class="string">'Volume'</span>: <span class="number">935000</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">with open(<span class="string">'stocks.csv'</span>,<span class="string">'w'</span>) as f:</span><br><span class="line">    f_csv = csv.<span class="symbol">DictWriter</span>(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>你应该总是优先选择 <code>csv</code> 模块分割或解析 <code>CSV</code> 数据。</p><p>例如，你可能会像编写类似下面这样的代码：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">    row = <span class="built_in">line</span>.<span class="built_in">split</span>(<span class="string">','</span>)</span><br><span class="line">    <span class="comment"># process row</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用这种方式的一个缺点就是你仍然需要去处理一些棘手的细节问题。比如，如果某些字段值被引号包围，你不得不去除这些引号。另外，如果一个被引号包围的字段碰巧含有一个逗号，那么程序就会因为产生一个错误大小的行而出错。</p><p>默认情况下， <code>csv</code> 库可识别 <code>Microsoft Excel</code> 所使用的 <code>CSV</code> 编码规则。这或许也是最常见的形式，并且也会给你带来最好的兼容性。然而，如果你查看 <code>csv</code> 的文档，就会发现有很多种方法将它应用到其他编码格式上（如修改分割字符等）。 例如，如果你想读取以 <code>tab</code> 分割的数据，可以这样做：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Example <span class="keyword">of</span> reading tab-separated values</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stock.tsv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_tsv = csv.reader(f, delimiter=<span class="string">'\t'</span>)</span><br><span class="line">    for row <span class="keyword">in</span> f_tsv:</span><br><span class="line">        # Process row</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>如果你正在读取 <code>CSV</code> 数据并将它们转换为命名元组，需要注意对列名进行合法性认证。例如，一个 <code>CSV</code> 格式文件有一个包含非法标识符的列头行，类似下面这样：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Street Address,Num-Premises,Latitude,Longitude <span class="number">5412</span> N CLARK,<span class="number">10</span>,<span class="number">41.980262</span>,<span class="number">-87.668452</span></span><br></pre></td></tr></table></figure><p>这样最终会导致在创建一个命名元组时产生一个 <code>ValueError</code> 异常而失败。 为了解决这问题，你可能不得不先去修正列标题。例如，可以像下面这样在非法标识符上使用一个正则表达式替换：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"><span class="function">with <span class="title">open</span>(<span class="params"><span class="string">'stock.csv'</span></span>) <span class="keyword">as</span> f:</span></span><br><span class="line"><span class="function">    f_csv </span>= csv.reader(f)</span><br><span class="line">    headers = [ re.sub(<span class="string">'[^a-zA-Z_]'</span>, <span class="string">'_'</span>, h) <span class="function"><span class="keyword">for</span> h <span class="keyword">in</span> <span class="title">next</span>(<span class="params">f_csv</span>) ]</span></span><br><span class="line"><span class="function">    Row </span>= namedtuple(<span class="string">'Row'</span>, headers)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        <span class="meta"># Process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>还有重要的一点需要强调的是， <code>csv</code> 产生的数据都是字符串类型的，它不会做任何其他类型的转换。如果你需要做这样的类型转换，你必须自己手动去实现。下面是一个在 <code>CSV</code> 数据上执行其他类型转换的例子：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">col_types = [str, float, str, str, float, int]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        <span class="comment"># Apply conversions to the row items</span></span><br><span class="line">        row = tuple(<span class="built_in">convert</span>(<span class="built_in">value</span>) <span class="keyword">for</span> <span class="built_in">convert</span>, <span class="built_in">value</span> <span class="keyword">in</span> zip(col_types, row))</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>另外，下面是一个转换字典中特定字段的例子：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="symbol">'Reading</span> <span class="keyword">as</span> dicts <span class="keyword">with</span> <span class="keyword">type</span> conversion')</span><br><span class="line">field_types = [ (<span class="symbol">'Price'</span>, <span class="built_in">float</span>),</span><br><span class="line">                (<span class="symbol">'Change'</span>, <span class="built_in">float</span>),</span><br><span class="line">                (<span class="symbol">'Volume'</span>, <span class="built_in">int</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">'stocks</span>.csv') <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv.<span class="type">DictReader</span>(f):</span><br><span class="line">        row.update((key, conversion(row[key]))</span><br><span class="line">                <span class="keyword">for</span> key, conversion <span class="keyword">in</span> field_types)</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><p>通常来讲，你可能并不想过多去考虑这些转换问题。 在实际情况中， <code>CSV</code> 文件都或多或少有些缺失的数据，被破坏的数据以及其它一些让转换失败的问题。因此，除非你的数据确实有保障是准确无误的，否则你必须考虑这些问题（你可能需要增加合适的错误处理机制）。</p><p>最后，如果你读取 <code>CSV</code> 数据的目的是做数据分析和统计的话， 你可能需要看一看 <code>Pandas</code> 包。 <code>Pandas</code> 包含了一个非常方便的函数叫 <code>pandas.read_csv()</code> ，它可以加载 <code>CSV</code> 数据到一个 <code>DataFrame</code> 对象中去 。 然后利用这个对象你就可以生成各种形式的统计、过滤数据以及执行其他高级操作了。 在 <code>6.13 小节</code> 中会有这样一个例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第六章：数据编码和处理&quot;&gt;&lt;a href=&quot;#第六章：数据编码和处理&quot; class=&quot;headerlink&quot; title=&quot;第六章：数据编码和处理&quot;&gt;&lt;/a&gt;第六章：数据编码和处理&lt;/h3&gt;&lt;p&gt;这一章主要讨论使用 &lt;code&gt;Python&lt;/code&gt; 处理各种不同方式编码的数据，比如 &lt;code&gt;CSV&lt;/code&gt; 文件， &lt;code&gt;JSON&lt;/code&gt; ， &lt;code&gt;XML&lt;/code&gt; 和二进制包装记录。和数据结构那一章不同的是，这章不会讨论特殊的算法问题，而是关注于怎样获取和存储这些格式的数据。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想读写一个 &lt;code&gt;CSV&lt;/code&gt; 格式的文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="数据编码和处理" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E5%92%8C%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>6.02 读写 JSON 数据</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/6-02-%E8%AF%BB%E5%86%99-JSON-%E6%95%B0%E6%8D%AE/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/6-02-读写-JSON-数据/</id>
    <published>2018-06-08T05:35:35.000Z</published>
    <updated>2018-06-08T05:58:42.378Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你想读写 <code>JSON(JavaScript Object Notation)</code> 编码格式的数据。</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>json</code> 模块提供了一种很简单的方式来编码和解码 <code>JSON</code> 数据。 其中两个主要的函数是 <code>json.dumps()</code> 和 <code>json.loads()</code> ，要比其他序列化函数库如 <code>pickle</code> 的接口少得多。 下面演示如何将一个 <code>Python</code> 数据结构转换为 <code>JSON</code> ：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> = &#123;</span></span><br><span class="line"><span class="class">    '<span class="title">name'</span> : '<span class="type">ACME</span>',</span></span><br><span class="line"><span class="class">    '<span class="title">shares'</span> : 100,</span></span><br><span class="line"><span class="class">    '<span class="title">price'</span> : 542.23</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="title">json_str</span> = json.dumps(<span class="class"><span class="keyword">data</span>)</span></span><br></pre></td></tr></table></figure><p>下面演示如何将一个 <code>JSON</code> 编码的字符串转换回一个 <code>Python</code> 数据结构：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = json.loads(<span class="title">json_str</span>)</span></span><br></pre></td></tr></table></figure><p>如果你要处理的是文件而不是字符串，你可以使用 <code>json.dump()</code> 和 <code>json.load()</code> 来编码和解码 <code>JSON</code> 数据。例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing JSON data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading data back</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'data.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.<span class="built_in">load</span>(f)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><code>JSON</code> 编码支持的基本数据类型为 <code>None ， bool ， int ， float</code> 和 <code>str</code> ，以及包含这些类型数据的 <code>lists</code> ，<code>tuples</code> 和 <code>dictionaries</code> 。对于 <code>dictionaries</code> ， <code>keys</code> 需要是字符串类型(字典中任何非字符串类型的 key 在编码时会先转换为字符串)。为了遵循 <code>JSON</code> 规范，你应该只编码 <code>Python</code> 的 <code>lists</code> 和 <code>dictionaries</code> 。而且，在 <code>web</code> 应用程序中，顶层对象被编码为一个字典是一个标准做法。</p><p><code>JSON</code> 编码的格式对于 <code>Python</code> 语法而已几乎是完全一样的，除了一些小的差异之外。比如， <code>True</code> 会被映射为 <code>true</code> ， <code>False</code> 被映射为 <code>false</code> ，而 <code>None</code> 会被映射为 <code>null</code> 。 下面是一个例子，演示了编码后的字符串效果：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(False)</span><br><span class="line"><span class="string">'false'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d = &#123;<span class="string">'a'</span>: True,</span><br><span class="line">...     <span class="string">'b'</span>: <span class="string">'Hello'</span>,</span><br><span class="line">...     <span class="string">'c'</span>: None&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"b": "Hello", "c": null, "a": true&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你试着去检查 <code>JSON</code> 解码后的数据，你通常很难通过简单的打印来确定它的结构，特别是当数据的嵌套结构层次很深或者包含大量的字段时。为了解决这个问题，可以考虑使用 <code>pprint</code> 模块的 <code>pprint()</code> 函数来代替普通的 <code>print()</code> 函数。它会按照 <code>key</code> 的字母顺序并以一种更加美观的方式输出。下面是一个演示如何漂亮的打印输出 <code>Twitter</code> 上搜索结果的例子：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib.request import urlopen</span><br><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; u = urlopen('http://search.twitter.com/search.json?q=python&amp;rpp=5')</span><br><span class="line">&gt;&gt;&gt; resp = json.loads(u.read().decode('utf-8'))</span><br><span class="line">&gt;&gt;&gt; from pprint import pprint</span><br><span class="line">&gt;&gt;&gt; pprint(resp)</span><br><span class="line">&#123;'completed_in': <span class="number">0.074</span>,</span><br><span class="line">'max_id': <span class="number">264043230692245504</span>,</span><br><span class="line">'max_id_str': '<span class="number">26404323069224</span><span class="number">5504</span>',</span><br><span class="line">'next_page': '?page=2&amp;max_id=<span class="number">26404323069224</span><span class="number">5504</span>&amp;q=python&amp;rpp=5',</span><br><span class="line">'page': <span class="number">1</span>,</span><br><span class="line">'query': 'python',</span><br><span class="line">'refresh_url': '?since_id=<span class="number">26404323069224</span><span class="number">5504</span>&amp;q=python',</span><br><span class="line">'results': [&#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:26 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:14 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:13 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:07 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;'created_at': 'Thu, 01 Nov <span class="number">2012</span> 16:36:04 +<span class="number">0000</span>',</span><br><span class="line">            'from_user': ...</span><br><span class="line">            &#125;],</span><br><span class="line">'results_per_page': <span class="number">5</span>,</span><br><span class="line">'since_id': <span class="number">0</span>,</span><br><span class="line">'since_id_str': '0'&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>一般来讲， <code>JSON</code> 解码会根据提供的数据创建 <code>dicts</code> 或 <code>lists</code> 。如果你想要创建其他类型的对象，可以给 <code>json.loads()</code> 传递 <code>object_pairs_hook</code> 或 <code>object_hook</code> 参数。例如，下面是演示如何解码 <code>JSON</code> 数据并在一个 <code>OrderedDict</code> 中保留其顺序的例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'&#123;"name": "ACME", "shares": 50, "price": 490.1&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from collections import OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = json.loads(s, object_pairs_hook=OrderedDict)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'ACME'</span>), (<span class="string">'shares'</span>, <span class="number">50</span>), (<span class="string">'price'</span>, <span class="number">490.1</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>下面是如何将一个 <code>JSON</code> 字典转换为一个 <code>Python</code> 对象例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">JSONObject</span>:</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, d)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">self</span>.__dict_<span class="number">_</span> = d</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = json.loads(s, object_hook=JSONObject)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data.name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data.shares</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data.price</span><br><span class="line"><span class="number">490.1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>最后一个例子中， <code>JSON</code> 解码后的字典作为一个单个参数传递给 <code>__init__()</code> 。 然后，你就可以随心所欲的使用它了，比如作为一个实例字典来直接使用它。</p><p>在编码 <code>JSON</code> 的时候，还有一些选项很有用。如果你想获得漂亮的格式化字符串后输出，可以使用 <code>json.dumps()</code> 的 <code>indent</code> 参数。它会使得输出和 <code>pprint()</code> 函数效果类似。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(json.dumps(data))</span><br><span class="line">&#123;<span class="string">"price"</span>: <span class="number">542.23</span>, <span class="string">"name"</span>: <span class="string">"ACME"</span>, <span class="string">"shares"</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(json.dumps(data, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"price"</span>: <span class="number">542.23</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ACME"</span>,</span><br><span class="line">    <span class="string">"shares"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>对象实例通常并不是 <code>JSON</code> 可序列化的。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, x, y)</span></span><span class="symbol">:</span></span><br><span class="line">...         <span class="keyword">self</span>.x = x</span><br><span class="line">...         <span class="keyword">self</span>.y = y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; json.dumps(p)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/__init__.py"</span>, line <span class="number">226</span>, <span class="keyword">in</span> dumps</span><br><span class="line">        <span class="keyword">return</span> _default_encoder.encode(obj)</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="number">187</span>, <span class="keyword">in</span> encode</span><br><span class="line">        chunks = <span class="keyword">self</span>.iterencode(o, _one_shot=True)</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="number">245</span>, <span class="keyword">in</span> iterencode</span><br><span class="line">        <span class="keyword">return</span> _iterencode(o, <span class="number">0</span>)</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="number">169</span>, <span class="keyword">in</span> default</span><br><span class="line">        raise TypeError(repr(o) + <span class="string">" is not JSON serializable"</span>)</span><br><span class="line"><span class="symbol">TypeError:</span> &lt;__main_<span class="number">_</span>.Point object at <span class="number">0x1006f2650</span>&gt; is <span class="keyword">not</span> JSON serializable</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想序列化对象实例，你可以提供一个函数，它的输入是一个实例，返回一个可序列化的字典。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize_instance</span></span>(obj):</span><br><span class="line">    d = &#123; <span class="symbol">'__classname_</span>_' : <span class="class"><span class="keyword">type</span>(<span class="params">obj</span>).<span class="title">__name__</span> &#125;</span></span><br><span class="line"><span class="class">    <span class="title">d</span>.<span class="title">update</span>(<span class="params">vars(obj</span>))</span></span><br><span class="line"><span class="class">    <span class="title">return</span> <span class="title">d</span></span></span><br></pre></td></tr></table></figure><p>如果你想反过来获取这个实例，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionary mapping names to known classes</span></span><br><span class="line">classes = &#123;</span><br><span class="line">    <span class="string">'Point'</span> : Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unserialize_object</span><span class="params">(d)</span>:</span></span><br><span class="line">    clsname = d.pop(<span class="string">'__classname__'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> clsname:</span><br><span class="line">        cls = classes[clsname]</span><br><span class="line">        obj = cls.__new__(cls) <span class="comment"># Make instance without calling __init__</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            setattr(obj, key, value)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure><p>下面是如何使用这些函数的例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">p</span> = Point(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; s = json.dumps(<span class="selector-tag">p</span>, default=serialize_instance)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line"><span class="string">'&#123;"__classname__": "Point", "y": 3, "x": 2&#125;'</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span> = json.loads(s, object_hook=unserialize_object)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;__main__<span class="selector-class">.Point</span> <span class="selector-tag">object</span> at <span class="number">0</span>x1017577d0&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">a</span>.y</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>json</code> 模块还有很多其他选项来控制更低级别的数字、特殊值如 <code>NaN</code> 等的解析。<br>可以参考官方文档获取更多细节 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;你想读写 &lt;code&gt;JSON(JavaScript Object Notation)&lt;/code&gt; 编码格式的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="数据编码和处理" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E5%92%8C%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>1.01 解压序列赋值给多个变量</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/1-01-%E8%A7%A3%E5%8E%8B%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/1-01-解压序列赋值给多个变量/</id>
    <published>2018-06-08T02:07:07.000Z</published>
    <updated>2018-06-08T05:32:51.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章：数据结构和算法"><a href="#第一章：数据结构和算法" class="headerlink" title="第一章：数据结构和算法"></a>第一章：数据结构和算法</h3><p><code>Python</code> 提供了大量的内置数据结构，包括列表，集合以及字典。大多数情况下使用这些数据结构是很简单的。但是，我们也会经常碰到到诸如查询，排序和过滤等等这些普遍存在的问题。因此，这一章的目的就是讨论这些比较常见的问题和算法。另外，我们也会给出在集合模块 <code>collections</code> 当中操作这些数据结构的方法。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>现在有一个包含 <code>N</code> 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 <code>N</code> 个变量 ？</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。唯一的前提就是变量的数量必须跟序列元素的数量是一样的。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x, y = p</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; y</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = [ <span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, shares, price, date = data</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; date</span><br><span class="line">(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, shares, price, (year, mon, day) = data</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; year</span><br><span class="line"><span class="number">2012</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; mon</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; day</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果变量个数和序列元素的个数不匹配，会产生一个异常。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x, y, z = p</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">ValueError:</span> need more than <span class="number">2</span> values to unpack</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>实际上，这种解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或者元组。 包括字符串，文件对象，迭代器和生成器。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a, b, c, d, e = s</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a</span><br><span class="line"><span class="string">'H'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; e</span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>有时候，你可能只想解压一部分，丢弃其他的值。对于这种情况 <code>Python</code> 并没有提供特殊的语法。但是你可以使用任意变量名去占位，到时候丢掉这些变量就行了。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = [ <span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="number">_</span>, shares, price, <span class="number">_</span> = data</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; shares</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; price</span><br><span class="line"><span class="number">91.1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>你必须保证你选用的那些占位变量名在其他地方没被使用到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一章：数据结构和算法&quot;&gt;&lt;a href=&quot;#第一章：数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;第一章：数据结构和算法&quot;&gt;&lt;/a&gt;第一章：数据结构和算法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 提供了大量的内置数据结构，包括列表，集合以及字典。大多数情况下使用这些数据结构是很简单的。但是，我们也会经常碰到到诸如查询，排序和过滤等等这些普遍存在的问题。因此，这一章的目的就是讨论这些比较常见的问题和算法。另外，我们也会给出在集合模块 &lt;code&gt;collections&lt;/code&gt; 当中操作这些数据结构的方法。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;现在有一个包含 &lt;code&gt;N&lt;/code&gt; 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 &lt;code&gt;N&lt;/code&gt; 个变量 ？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="数据结构和算法" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>1.02 解压可迭代对象赋值给多个变量</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/1-02-%E8%A7%A3%E5%8E%8B%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/1-02-解压可迭代对象赋值给多个变量/</id>
    <published>2018-06-08T02:07:04.000Z</published>
    <updated>2018-06-08T05:30:08.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 <code>ValueError</code> 。 那么怎样才能从这个可迭代对象中解压出 <code>N</code> 个元素出来？</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>Python</code> 的星号表达式可以用来解决这个问题。比如，你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是排除掉第一个和最后一个分数。如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有 <code>24</code> 个呢？这时候星号表达式就派上用场了：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def drop_first_last(grades):</span><br><span class="line">    <span class="keyword">first</span>, *<span class="keyword">middle</span>, <span class="keyword">last</span> = grades</span><br><span class="line">    <span class="literal">return</span> <span class="built_in">avg</span>(<span class="keyword">middle</span>)</span><br></pre></td></tr></table></figure><p>另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 你可以像下面这样分解这些记录：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; record = (<span class="string">'Dave'</span>, <span class="string">'dave@example.com'</span>, <span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, email, *phone_numbers = record</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'Dave'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; email</span><br><span class="line"><span class="string">'dave@example.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; phone_numbers</span><br><span class="line">[<span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>值得注意的是上面解压出的 <code>phone_numbers</code> 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 <code>0</code> 个）。 所以，任何使用到 <code>phone_numbers</code> 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。</p><p>星号表达式也能用在列表的开始部分。比如，你有一个公司前 <code>8</code> 个月销售数据的序列，但是你想看下最近一个月数据和前面 <code>7</code> 个月的平均值的对比。你可以这样做：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*trailing_qtrs, current_qtr = sales_record</span><br><span class="line">trailing_avg = <span class="built_in">sum</span>(trailing_qtrs) / <span class="built_in">len</span>(trailing_qtrs)</span><br><span class="line"><span class="literal">return</span> avg_comparison(trailing_avg, current_qtr)</span><br></pre></td></tr></table></figure><p>下面是在 <code>Python</code> 解释器中执行的结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; *trailing, current = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; trailing</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">&gt;&gt;&gt; current</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。通常，这些可迭代对象的元素结构有确定的规则（比如第 <code>1</code> 个元素后面都是电话号码），星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。而不是通过一些比较复杂的手段去获取这些关联的元素值。</p><p>值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。 比如，下面是一个带有标签的元组序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">records = [</span><br><span class="line">    (<span class="string">'foo'</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">'bar'</span>, <span class="string">'hello'</span>),</span><br><span class="line">    (<span class="string">'foo'</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_foo</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'foo'</span>, x, y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_bar</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">'bar'</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tag, *args <span class="keyword">in</span> records:</span><br><span class="line">    <span class="keyword">if</span> tag == <span class="string">'foo'</span>:</span><br><span class="line">        do_foo(*args)</span><br><span class="line">    <span class="keyword">elif</span> tag == <span class="string">'bar'</span>:</span><br><span class="line">        do_bar(*args)</span><br></pre></td></tr></table></figure><p>星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; line = <span class="string">'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; uname, *fields, homedir, sh = line.split(<span class="string">':'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; uname</span><br><span class="line"><span class="string">'nobody'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; homedir</span><br><span class="line"><span class="string">'/var/empty'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sh</span><br><span class="line"><span class="string">'/usr/bin/false'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>有时候，你想解压一些元素后丢弃它们，你不能简单就使用<code>*</code>，但是你可以使用一个普通的废弃名称，比如 <code>_</code> 或者 <code>ign （ignore）</code>。</p><p>代码示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; record = (<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">123.45</span>, (<span class="number">12</span>, <span class="number">18</span>, <span class="number">2012</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name, *<span class="number">_</span>, (*<span class="number">_</span>, year) = record</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; year</span><br><span class="line"><span class="number">2012</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。比如，如果你有一个列表，你可以很容易的将它分割成前后两部分：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; items = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt; head, *tail = items</span><br><span class="line">&gt;&gt;&gt; head</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; tail</span><br><span class="line">[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(items)</span></span><span class="symbol">:</span></span><br><span class="line">...     head, *tail = items</span><br><span class="line">...     <span class="keyword">return</span> head + sum(tail) <span class="keyword">if</span> tail <span class="keyword">else</span> head</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sum(items)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>然后，由于语言层面的限制，递归并不是 <code>Python</code> 擅长的。因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 &lt;code&gt;ValueError&lt;/code&gt; 。 那么怎样才能从这个可迭代对象中解压出 &lt;code&gt;N&lt;/code&gt; 个元素出来？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="数据结构和算法" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>1.03 保留最后 N 个元素</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/1-03-%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E-N-%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/1-03-保留最后-N-个元素/</id>
    <published>2018-06-08T02:07:02.000Z</published>
    <updated>2018-06-08T05:24:57.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？</p><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>保留有限历史记录正是 <code>collections.deque</code> 大显身手的时候。</p><p>比如，下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(lines, pattern, history=<span class="number">5</span>)</span>:</span></span><br><span class="line">    previous_lines = deque(maxlen=history)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">yield</span> line, previous_lines</span><br><span class="line">        previous_lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use on a file</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r'../../cookbook/somefile.txt'</span>,<span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line, prevlines <span class="keyword">in</span> search(f, <span class="string">'python'</span>, <span class="number">5</span>):</span><br><span class="line">            <span class="keyword">for</span> pline <span class="keyword">in</span> prevlines:</span><br><span class="line">                print(pline, end=<span class="string">''</span>)</span><br><span class="line">            print(line, end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">'-'</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>我们在写查询元素的代码时，通常会使用包含 <code>yield</code> 表达式的生成器函数，也就是我们上面示例代码中的那样。这样可以将搜索过程代码和使用搜索结果代码解耦。</p><p>使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候，最老的元素会自动被移除掉。</p><p>代码示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span> = deque(maxlen=<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">3</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">3</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><p>尽管你也可以手动在一个列表上实现这一的操作（比如增加、删除等等）。但是这里的队列方案会更加优雅并且运行得更快些。</p><p>更一般的， <code>deque</code> 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p><p>代码示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span> = deque()</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.append(<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.appendleft(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line"><span class="function"><span class="title">deque</span><span class="params">([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">q</span>.popleft()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>在队列两端插入或删除元素时间复杂度都是 <code>O(1)</code> ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 <code>O(N)</code> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="数据结构和算法" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>1.04 查找最大或最小的 N 个元素</title>
    <link href="http://codebooks.dongfei.xin/2018-06-08/1-04-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E6%88%96%E6%9C%80%E5%B0%8F%E7%9A%84-N-%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://codebooks.dongfei.xin/2018-06-08/1-04-查找最大或最小的-N-个元素/</id>
    <published>2018-06-08T02:07:00.000Z</published>
    <updated>2018-06-08T05:22:44.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>怎样从一个集合中获得最大或者最小的 <code>N</code> 个元素列表？<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>heapq</code> 模块有两个函数：<code>nlargest()</code> 和 <code>nsmallest()</code> 可以完美解决这个问题。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums)) # Prints [<span class="number">42</span>, <span class="number">37</span>, <span class="number">23</span>]</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums)) # Prints [<span class="number">-4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>两个函数都能接受一个关键字参数，用于更复杂的数据结构中：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=lambda s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=lambda s: s[<span class="string">'price'</span>])</span><br></pre></td></tr></table></figure><p>译者注：上面代码在对每个元素进行对比的时候，会以 <code>price</code> 的值进行比较。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>如果你想在一个集合中查找最小或最大的 <code>N</code> 个元素，并且 <code>N</code> 小于集合元素数量，那么这些函数提供了很好的性能。因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt; import heapq</span><br><span class="line">&gt;&gt;&gt; heap = <span class="type">list</span>(nums)</span><br><span class="line">&gt;&gt;&gt; heapq.heapify(heap)</span><br><span class="line">&gt;&gt;&gt; heap</span><br><span class="line">[<span class="number">-4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">8</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>堆数据结构最重要的特征是 <code>heap[0]</code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code>heapq.heappop()</code>方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是<code>O(log N)</code> ， <code>N</code> 是堆大小）。 比如，如果想要查找最小的 <code>3</code> 个元素，你可以这样做：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; heapq.heappop(heap)</span><br><span class="line">-<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heapq.heappop(heap)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heapq.heappop(heap)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>当要查找的元素个数相对比较小的时候，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 是很合适的。 如果你仅仅想查找唯一的最小或最大（<code>N=1</code>）的元素的话，那么使用<code>min()</code> 和 <code>max()</code> 函数会更快些。 类似的，如果 <code>N</code> 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ <code>sorted(items)[:N]</code> 或者是 <code>sorted(items)[-N:]</code> ）。 需要在正确场合使用函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才能发挥它们的优势 （如果 <code>N</code> 快接近集合大小了，那么使用排序操作会更好些）。</p><p>尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且值得你深入学习的东西。 基本上只要是数据结构和算法书籍里面都会有提及到。 <code>heapq</code> 模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;怎样从一个集合中获得最大或者最小的 &lt;code&gt;N&lt;/code&gt; 个元素列表？&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/categories/Python/"/>
    
      <category term="数据结构和算法" scheme="http://codebooks.dongfei.xin/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://codebooks.dongfei.xin/tags/Python/"/>
    
  </entry>
  
</feed>
